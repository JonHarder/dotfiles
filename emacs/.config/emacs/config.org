
#+TITLE: Literate Emacs Config
#+AUTHOR: Jon Harder
#+STARTUP: fold
* Overview
This configuration combines the documentation and organization of a
literate config file using org mode, and the quick parsing and starwrite the code into
dedicated elisp files.

The secret to this configuration is the ~:tangle SOURCE~ syntax which
writes the contents to the specified file. In order to keep this up to
date, the emacs command, ~M-x org-babel-tangle~ must be ran after
modifying this file.

* Base Settings

Sets things like the theme and font.  Actually using and loading
themes, setting font configuration, etc. is handled later in the
configuration.

#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (defvar my-theme '(doom-themes . doom-material-dark)
    "Cons of the symbols representing the theme package, and theme name.")
  
  (defvar my-font '(:name "JetBrains Mono" :size 170)
    "Font (:name string :size integer).")
#+end_src
* Early init optimizations
** Disable built-in package.el
 #+begin_src emacs-lisp :tangle "early-init.el"
   ;;; early-init.el --- The first lisp code emacs runs before normal initialization. -*- lexical-binding: t -*-
   ;;; Commentary:
   ;; This file is evaluated at the very start of Emacs initialization.
   ;; It is used here to ensure the native `package' initialization is inhibeted.

   ;;; Code:

   ;; disable package.el in favor of straight.el
   (setq package-enable-at-startup nil)
 #+end_src

  #+RESULTS:

** Startup performance enhancements
The aim here is to effectively disable the garbage collector during startup
as Emacs is not interactible during startup anyway. In the startup-hook we
restore these settings to sensible values for runtime.

 #+begin_src emacs-lisp :tangle early-init.el
   (setq gc-cons-threshold most-positive-fixnum
         gc-cons-percentage 0.5)
 #+end_src

** Performance monitoring
It's helpful to track how long Emacs takes to load up. This normally
isn't the most critical metric to track as I usually run emacs with
~emacs --daemon~, and open new emacs windows with ~emacsclient~, but
helpful nonetheless.

#+begin_src emacs-lisp :tangle "early-init.el"
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 1024 1024 20)
                    gc-cons-percentage 0.2)
              (message "*** Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))

  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

* Package management
** Set up straight.el (package management)

 #+begin_src emacs-lisp :tangle "init.el"
   ;;; init --- Basic, initial settings -*- lexical-binding: t -*-

   ;;; Commentary:
   ;;; This setups up straight.el for package management and
   ;;; loads my modules

   ;;; Code:

   (setq straight-repository-branch "develop")

   (defvar bootstrap-version)
   (let ((bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-verision 6))
     (unless (file-exists-p bootstrap-file)
       (with-current-buffer
   		(url-retrieve-synchronously
   		 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
   		 'silent 'inhibit-cookies)
         (goto-char (point-max))
         (eval-print-last-sexp)))
     (load bootstrap-file nil 'nomessage))
   (setq straight-built-in-pseudo-packages
   	  '(emacs nadvice python image-mode project flymake))
 #+end_src
** Local lisp loading
*** Load local-config
There are some configuration settings that are local to the particular
machine I'm running emacs on. These settings are stored in the file,
=local-config.el=.

This gets loaded first so that any later configuration can utilize it.

#+begin_src emacs-lisp :tangle "init.el"
  (load-file (expand-file-name "local-config.el" user-emacs-directory))
#+end_src
*** Adding my-modules to the load path
#+begin_src emacs-lisp :tangle "init.el"
   (add-to-list 'load-path (locate-user-emacs-file "my-modules"))
#+end_src

** Require all my modules
#+begin_src emacs-lisp :tangle "init.el"
  (require 'my-appearance)
  (require 'my-util)
  (require 'my-core)
  (require 'my-mouse)
  (require 'my-meow)
  (require 'my-modeline)

  (require 'my-calendar)
  (require 'my-completion)
  (require 'my-tree-sitter)
  (require 'my-gtd)
  (require 'my-denote)
  (require 'my-dired)
  (require 'my-docker-mode)
  (require 'my-ediff)
  (require 'my-email)
  (require 'my-epub)
  (require 'my-feed)
  (require 'my-gpg)
  (require 'my-go-mode)
  (require 'my-help)
  (require 'my-http)
  (require 'my-icons)
  (require 'my-lisp-mode)
  (require 'my-git)
  (require 'my-markup)
  (require 'my-navigation)
  (require 'my-web)
  (require 'my-neon-mode)
  (require 'my-nushell-mode)
  (require 'my-org)
  (require 'my-php-mode)
  (require 'my-prog-mode)
  (require 'my-python-mode)
  (require 'my-rest-mode)
  (require 'my-text)
  (require 'my-timers)
  (require 'my-just)
  (require 'my-jj)
  (require 'my-avy)
  (require 'my-registers)

  (require 'my-rust-mode)
  (require 'my-search)
  (require 'my-shells)
  (require 'my-typst)
  (require 'my-terraform-mode)
  (require 'my-vim-mode)

  (provide 'init)
  ;;; init.el ends here
#+end_src

* Utility functions
  This is a collection of random functions I've written to help me run one-off tasks.
  
#+begin_src emacs-lisp :tangle "my-modules/my-util.el" :mkdirp yes
  ;; -*- lexical-binding: t; -*-
  (defun find-config ()
    "Open the user's config file."
    (interactive)
    (find-file (concat user-emacs-directory "config.org")))

  (defun masteringemacs ()
    "Open the masteringemacs epub manual."
    (interactive)
    ;; ensure the nov package is installed
    (require 'nov)
    (find-file "~/Dropbox/Emacs/mastering-emacs-v4.epub"))

  (defun add-to-path (value &optional prepend)
    "Add VALUE to the PATH environment variable.

  This handles reading the current value of PATH and appends the given
  value to the end of it, or to the beginning if PREPEND is non nil.

  VALUE should be the raw string to add, `add-to-path' will handle
  ensuring the final value contains the necessary ':'."
    (interactive "DPath: ")
    (let ((path (getenv "PATH")))
  	(setenv "PATH"
  			(concat path value ":"))))

  (provide 'my-util)
#+end_src
* Appearance
** Color theme

The modus theme set is the most complete and polished emacs color
theme I've encountered. It's also WCAG 2 compliant meaning it will
always have high color contrast between UI elements, making it one of
the easiest themes on the eyes in any lighting situation.

#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (straight-use-package (car my-theme))
  (load-theme (cdr my-theme) t)
#+end_src

*** Settings
**** Basic theme configuration
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (set-face-attribute 'bold nil :weight 'ultra-bold)
  (when t
    (custom-set-faces
     '(org-level-1 ((t (:height 1.3 :inherit outline-1))))
     '(org-level-2 ((t (:height 1.2 :inherit outline-2))))
     '(org-level-3 ((t (:height 1.2 :inherit outline-3))))
     '(org-level-4 ((t (:height 1.2 :inherit outline-4))))
     '(org-level-5 ((t (:height 1.1 :inherit outline-5))))
     '(org-document-title ((t (:height 2.5 :underline t))))))
#+end_src
**** Modus themes settings
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (when (eq 'modus-themes (car my-theme)) ;; Modus configuration
    (require-theme 'modus-themes)
    (setq modus-themes-completions
  		'((matches . (extrabold underline))
            (selection . (semibold italic))))
    (setq modus-themes-prompts '(bold))
    (setq modus-themes-bold-constructs t)
    (setq modus-themes-common-palette-overrides
  		modus-themes-preset-overrides-intense)
    (setq modus-themes-variable-pitch-ui nil)
    (setq modus-themes-italic-constructs t)
    (setq modus-themes-org-blocks 'gray-background)
    ;; TODO set this to nil if a non-modus theme is active?
    (setq modus-themes-headings
  		'((1 . (1.3))
            (2 . (1.2))
  		  (3 . (1.2))
  		  (4 . (1.2))
            (agenda-date . (1.3))
            (agenda-structure . (variable-pitch light 1.8))
            (t . (1.1)))))
#+end_src
**** Doom themes settings

#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (when (eq 'doom-themes (car my-theme))
    (setq doom-rouge-brighter-comments t
  		doom-themes-enable-bold t
  		doom-themes-enable-italic t))
#+end_src

** Tweak display of UI elements
*** Menu bar mode

The menu bar is the list of contextual dropdown options in the top of the
application (or in the universal top bar on macs).

I'm all for getting rid of UI clutter, especially if it's unused, but there
are a lot of features in emacs... Having contextual help aids discoverability,
and so it stays on.
   
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (menu-bar-mode 1)
#+end_src
   
*** Scroll bar mode
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (scroll-bar-mode -1)
#+end_src
*** Tool bar mode
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (tool-bar-mode -1)
#+end_src

** Frame settings
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (setq frame-resize-pixelwise t
        frame-inhibit-implied-resize t
        inhibit-splash-screen t
        inhibit-startup-screen t)
#+end_src
** Bells are evil
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (setq ring-bell-function 'ignore)
#+end_src
** Time display
*** Format
I like 24 hour time; one time being ambiguous is unnecessarily cumbersome.

#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (setq display-time-24hr-format t)
#+end_src

*** Add the time to the mode line

#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (display-time)
#+end_src

** Font

I use [[https://www.jetbrains.com/lp/mono/][JetBrains Mono]]

#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (set-face-attribute 'default nil
  					:family (plist-get my-font :name)
  					:height (plist-get my-font :size))

  (add-hook 'after-make-frame-functions
            (lambda (frame)
              (let ((size (plist-get my-font :size))
  				  (font (plist-get my-font :name))
  				  (theme (cdr my-theme)))
  			  (with-selected-frame frame
  				(set-face-attribute 'default nil
  									:font font
  									:height size)
  				(set-frame-font font nil t)
  				(add-to-list 'default-frame-alist
  							 `(font . ,font))
  				(load-theme theme t)))))
#+end_src

** Tabs
Tabs are a useful workspace organization concept. You can have discrete window/buffer arrangements per tab,
allowing you to switch between them at will. They are pretty flexible so you could use them for keeping
track of different projects. Or you could have different window configuations for the same set of buffers
on different tabs to help with different types of work within the same project.

#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
   (setq tab-bar-show 1)
#+end_src
** Spacious Padding
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (straight-use-package 'spacious-padding)
#+end_src

** provide the module
#+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
  (provide 'my-appearance)
#+end_src
* Meow mode
** Install and require package
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
  (straight-use-package 'meow)
  (require 'meow)
#+end_src

** setup the core settings
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
  (defun meow-setup-core ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty))
#+end_src

** Set up motion state bindings
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
  (meow-motion-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
#+end_src

** Set up leader (keypad) state bindings
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
  (defun gtd-find-file ()
    (interactive)
    (find-file (concat gtd-directory "/gtd.org")))

  (meow-leader-define-key
   '("RET" . embark-act)
   ;; file/buffer commands
   '("ff" . find-file)
   '("fg" . gtd-find-file)
   '("fi" . gtd-find-inbox)
   '("fc" . find-config)
   '("bs" . save-buffer)
   '("bb" . consult-buffer)
   '("bi" . ibuffer)
   '("i" . consult-imenu)
   ;; programming keymap
   ;; currently just maps to `eglot-mode-map'
   ;; terminals/vc
   '("sv" . vterm)
   '("se" . eshell)
   ;; code things
   '("ed" . eldoc)
   '("ee" . eglot)
   
   '("a" . avy-goto-char-timer)
   '("oo" . occur)
   '("l" . recenter-top-bottom)
   ;; apps (org agenda, etc)
   '("oa" . org-agenda)
   '("oc" . org-capture)
   '("j" . jj-log)
   ;; denote bindings
   '("nb" . denote-backlinks)
   '("nn" . denote-open-or-create)
   '("nj" . denote-journal-new-or-existing-entry)
   '("ng" . consult-denote-grep)
   ;; tab bindings
   '("tt" . tab-switch)
   '("tr" . tab-rename)
   '("tn" . tab-new)
   '("tj" . tab-next)
   '("tk" . tab-previous)
   '("td" . tab-close)
   ;; window management
   '("ww" . ace-window)
   '("wv" . split-window-right)
   '("ws" . split-window-below)
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
#+end_src

** Set up org-motion state bindings
This is a new state we add to meow to make navigating around org
documents easier.  In meow, this is extremely easy.  Compliments to
[[https://aatmunbaxi.netlify.app/comp/meow_state_org_speed/][abaxi]] for the code.

#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
  (setq meow-org-motion-keymap (make-keymap))
  (meow-define-state org-motion
    "Org-mode structural motion"
    :lighter "[O]"
    :keymap meow-org-motion-keymap)

  (meow-define-keys 'org-motion
    '("<escape>" . meow-normal-mode)
    '("i" . meow-insert-mode)
    '("g" . meow-normal-mode)
    '("u" . meow-undo)
    ;; Moving between headlines
    '("k" . org-previous-visible-heading)
    '("j" . org-next-visible-heading)
    ;; moving between headings at the same level
    '("p" . org-backward-heading-same-level)
    '("n" . org-forward-heading-same-level)
    ;; Moving subtrees themselves
    '("K" . org-move-subtree-up)
    '("J" . org-move-subtree-down)
    ;; subtree de/promotion
    '("L" . org-demote-subtree)
    '("H" . org-promote-subtree)
    '(">" . org-demote-subtree)
    '("<" . org-promote-subtree)
    ;; Completion-style search of headings
    '("v" . consult-org-heading)
    ;; setting subtree metadata
    '("l" . org-set-property)
    '("t" . org-todo)
    '("d" . org-deadline)
    '("s" . org-schedule)
    '("e" . org-set-effort)
    ;; Block navigation
    '("b" . org-previous-block)
    '("f" . org-next-block)
    ;; Narrowing/widening
    '("N" . org-narrow-to-subtree)
    '("W" . widen))
#+end_src

** Set up normal state bindings
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '(">" . meow-indent)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)

   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-org-motion-mode)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("/" . consult-line)
   '(":" . execute-extended-command)
   '("<escape>" . ignore))
#+end_src
** Setting initial state for some major modes
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdir yes
  (add-hook 'vterm-mode-hook #'meow-insert)
  (add-hook 'eshell-mode-hook #'meow-insert)
  (add-hook 'org-capture-mode-hook #'meow-insert)
#+end_src
** Load setup functions and enable meow
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
    (meow-global-mode 1)

  (keymap-global-set "C-<return>" #'embark-act)
  (keymap-global-set "s-<return>" #'embark-dwim)

  ;; adding a specific keybinding for org mode since it already binds this binding
  (with-eval-after-load 'org
    (keymap-set org-mode-map "C-<return>" #'embark-act))
#+end_src
** Provide the module
#+begin_src emacs-lisp :tangle "my-modules/my-meow.el" :mkdirp yes
  (provide 'my-meow)
#+end_src

* mode line
** Doom modeline
#+begin_src emacs-lisp :tangle "my-modules/my-modeline.el" :mkdirp yes
  (straight-use-package 'doom-modeline) 
  (setq doom-modeline-height 35)
  (setq doom-modeline-bar-width 4)
  (setq doom-modeline-hud t)
  (setq doom-modeline-major-mode-color-icon t)
  (setq doom-modeline-enable-word-count t)

  ;; (straight-use-package 'doom-modeline-now-playing)
  ;; (require 'doom-modeline-now-playing)
  ;; (doom-modeline-now-playing-timer)

  (doom-modeline-mode 1)
  #+end_src
  
** require the mode line
#+begin_src emacs-lisp :tangle "my-modules/my-modeline.el" :mkdirp yes
  (provide 'my-modeline)
#+end_src

* Base settings
** Customization file

Here's just a holding ground for general emacs settings that
don't seem to fit in any more specific location.

When emacs makes customizations on my behalf, it throws the
resultant elist code into my init file. It's great that it
produces visible, editable, version controllable config, but
I don't like it in my init file. Let's move it somewhere else.

#+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
  (setq custom-file (concat user-emacs-directory "custom.el"))
#+end_src

** Backups

Emacs helpfully creates local backups of any files you're editing so that
if something happens to your session before saving the file, you'll have
a backup of the local changes.

It *un*-helpfully defaults to placing them in the same directory as the file
you are editing. This clutters things up immensely, particularily when you
are working in a version-controlled project and have to tell your VC tool
to ignore them.

Much better to just place them in a dedicated directory and forget about them.
Emacs will still save the day if something happens, but you don't have to
worry about it.

#+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
  (setq backup-directory-alist '(("." . "~/.backups")))
#+end_src

** Dictionary

Emacs has built in dictionary support (because of course it does). By dafault, it
expects you to be running a dictionary server ~dictd~ locally. If it can't be found,
it falls back to dict.org. I'm fine with going over the wire for my definitions,
so let's just set it as default.

#+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
  (setq dictionary-server "dict.org")
#+end_src

** Provide the module

#+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
  (provide 'my-core)
#+end_src

* Mouse settings
#+begin_src emacs-lisp :tangle "my-modules/my-mouse.el" :mkdirp yes
  (setq mouse-autoselect-window t)
  (provide 'my-mouse)
#+end_src
* Calendar
** Bindings

I really want hjkl for day navigation in calendar. [[Meow mode]] already
supplies j and k, so we just need to set l and h

#+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp yes
  (keymap-set calendar-mode-map (kbd "h") #'calendar-backward-day)
  (keymap-set calendar-mode-map (kbd "l") #'calendar-forward-day)
#+end_src
** Base settings

Set the date style to iso (day month year).

#+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp yes
  (setq calendar-date-style 'iso)
#+end_src
** Diary

The diary is (for me) mostly a way to jot down an appointment or reminder.

#+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp yes
    (appt-activate 1)
#+end_src

** Provide the module

#+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp yes
  (provide 'my-calendar)
#+end_src
* Completion

** General minibuffer settings

   When interacting with the [[elisp:(info "(emacs) Minibuffer")][minibuffer]], you may want to execute a command
   that itself occupies the minibuffer. Enabling recursive-minibuffers allows
   for you to nest arbitrarily deep minibuffer commands.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (setq enable-recursive-minibuffers t)
   #+end_src

   When you've used a command once, you will probably use it again in the near
   future. savehist is a simple package that remembers and promotes recent
   commands to the top of the prompted list of completions.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (straight-use-package 'savehist)
     (savehist-mode)
   #+end_src

   Do not allow the cursor in the minibuffer

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (setq minibuffer-prompt-properties
     	  '(read-only t cursor-intangible t face minibuffer-prompt))
     (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
   #+end_src
   
** Capf autosuggest
This is disabled until I can find a way to make suggestion usage work
and play nicely with ~eshell-smart~

#+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
  ;; (straight-use-package 'capf-autosuggest)
  ;; (add-hook 'eshell-mode-hook #'capf-autosuggest-mode)
  ;; (with-eval-after-load 'capf-autosuggest
  ;;   (add-to-list 'capf-autosuggest-capf-functions #'capf-autosuggest-orig-capf))
#+end_src
** Vertico

   Vertico is a minibuffer completion enhancement library which wraps emacs'
   built in [[elisp:(info "(emacs) Completion")][completion]] functionality. It is a member of a new era of packages
   which seek to enhance existing methods in emacs, rather than replace them
   entirely (looking at you helm).

   Vertico specifically seeks to enhance `completing-read', a generic method
   that prompts users to select from one of a provided set of alternatives.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (straight-use-package 'vertico)
     (vertico-mode 1)
     (define-key vertico-map (kbd "<escape>") #'keyboard-escape-quit)
   #+end_src

   Vertico also has a small stable of add-ons which change the default
   UI or behavior of vertico. Here vertico-directory is enabled, which
   introduces commands to delete directories fragments of the prompted
   file-path.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (require 'vertico-directory)
     (define-key vertico-map (kbd "DEL") #'vertico-directory-delete-char)
     (define-key vertico-map (kbd "RET") #'vertico-directory-enter)
   #+end_src

   Wipe the shadowed input in minibuffer when the current input superscedes
   it, e.g. =~/some/path/~/base= should erase =~/some/path= since =~/base= shadows
   it.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
   #+end_src

** Corfu

  Corfu offers completion in buffer, replacing company mode which sidesteps
  Emacs' built in completion mechanisms.

  #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
    (straight-use-package 'corfu)
    (setq corfu-auto t
          corfu-separator ?\s
          tab-always-indent 'complete)
    (global-corfu-mode 1)
  #+end_src

** Marginalia

   Marginalia is a small package that adds contextual information "in the margins"
   of the completion. It is a perfect compliment to the work of vertico (or
   other completion frameworks, it doesn't care)

   This means file prompts will contain file permissions, last modified time,
   file size. Commands will display their doc string, etc.

  #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (straight-use-package 'marginalia)
     (marginalia-mode 1)
   #+end_src

** Orderless

   The orderless package allows for fuzzy searching of terms sepparated by spaces
   (by default) and finds results regardless of search term order, thus, orderless.

  #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
    (straight-use-package 'orderless)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion))))
   #+end_src
   
** Consult

#+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
  (straight-use-package 'consult)
#+end_src

*** consult dir
#+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
  (straight-use-package 'consult-dir)
  (define-key vertico-map
              (kbd "M-c") #'consult-dir)
  (when nil
      (evil-define-key 'normal
  		     global-map
  		     (kbd "<leader> c d") #'consult-dir))
#+end_src


** Embark

It's kinda like right click, for your keyboard.
Activating embark gives you a context-aware menu
of actions to perform on the target under point.

#+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
  (straight-use-package 'embark)
  (straight-use-package 'embark-consult)

  ;; This sets embark as the help command when I'm looking for which
  ;; keybindings are available to complete a given prefix.  The
  ;; advantage of this is
  ;;
  ;; 1.) I only have to see the popup when I want to 
  ;;
  ;; 2.) the selection is filterable using the names of the functions
  (setq prefix-help-command #'embark-prefix-help-command)
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)

  (setq embark-indicators
        '(embark-minimal-indicator  ; default is embark-mixed-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  ;; This configures vertico to display these embark action tips in a
  ;; grid-like manner, similar to which-key.

  ;; (setq vertico-multiform-categories nil)
  (with-eval-after-load 'vertico
    (require 'vertico-multiform)
    (add-to-list 'vertico-multiform-categories '(embark-keybinding grid))
    (vertico-multiform-mode))

  ;;; bindings
  (define-key minibuffer-local-map
              (kbd "C-<return>") #'embark-act)
#+end_src
   
** Provide the module
#+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
  (provide 'my-completion)
#+end_src
 
* Icons
** Set up all the icons
#+begin_src emacs-lisp :tangle "my-modules/my-icons.el" :mkdirp yes
  ;; Icons
  (straight-use-package 'all-the-icons)
  ;;; If icons aren't showing up, you may need to install the font.
  ;;; If so, uncomment and execute the following line.
  ;; (all-the-icons-install-fonts t)
#+end_src

** And completion support for all the icons

#+begin_src emacs-lisp :tangle "my-modules/my-icons.el" :mkdirp yes
  (straight-use-package 'all-the-icons-completion)
  (all-the-icons-completion-mode)
  (if (require 'marginalia nil nil)
  	(add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))
#+end_src

** Provide the module

#+begin_src emacs-lisp :tangle "my-modules/my-icons.el" :mkdirp yes
    (provide 'my-icons)
  #+end_src 

* Ediff
** Window management
Ediff puts its control panal in a separate frame, which makes tiling window managers
quite unhappy. Let's configure it to use the /plain/ setup which just makes a small
window at the bottom of the current frame.
   
#+begin_src emacs-lisp :tangle "my-modules/my-ediff.el" :mkdirp yes
  (require 'ediff)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

** Provide =my-ediff=
#+begin_src emacs-lisp :tangle "my-modules/my-ediff.el" :mkdirp yes
  (provide 'my-ediff)
#+end_src
  
* Getting Things Done (GTD)
#+begin_src emacs-lisp :tangle "my-modules/my-gtd.el" :mkdirp yes
  (defvar gtd-directory (expand-file-name "~/Dropbox/org/gtd")
    "The directory my 'Getting Things Done' system is stored in")

  (defun gtd-find-oneoff ()
    "Open GTD one off file."
    (interactive)
    (find-file (concat gtd-directory "/oneoff.org")))

  (defun gtd-find-schedule ()
    "Open GTD schedule file."
    (interactive)
    (find-file (concat gtd-directory "/schedule.org")))

  (defun gtd-find-inbox ()
    "Open GTD inbox file."
    (interactive)
    (find-file (concat gtd-directory "/inbox.org")))

  (defun gtd-review ()
    "Review inbox and all tasks for clarification and pruning."
    (interactive)
    (delete-other-windows)
    (gtd-find-inbox)
    (split-window-right)
    (org-agenda nil "g"))

  (defun gtd-engage ()
    "Actually get some work done.

  Opens the \"daily\" custom org agenda command."
    (interactive)
    (org-agenda nil "d"))

  (defun gtd-capture ()
    "Capture a thought and store in my gtd inbox."
    (interactive)
    (org-capture nil "i"))

  (provide 'my-gtd)
#+end_src
* Denote
** Basic settings
#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (straight-use-package 'denote)

  (denote-rename-buffer-mode 1)
  (setq denote-known-keywords '("emacs" "work" "article" "notes" "blog"))

  (setq denote-directory (expand-file-name "~/Dropbox/org/zettelkasten"))

  (setq denote-dired-directories-include-subdirectories t
        denote-dired-directories (list denote-directory))
  (setq denote-prompts '(title subdirectory keywords))
#+end_src

** Bindings

#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  ;;; Code:
  (defun denote-recently-modified (&optional last-days)
    "View a `dired' buffer containing notes modified in the last LAST-DAYS days.

  This uses the first element of `denote-directories' to determine where notes are stored."
    (interactive (list
                  (read-number "Last days: " 7)))
    (let* ((default-directory (car (denote-directories)))
           ;; find files recently modified and sort by modification time
           (find-command (format "find . -type f -mtime -%d ! -name .DS_Store | xargs ls -t | cut -c3-"
                                 last-days))
           (files (split-string
                   (shell-command-to-string find-command))))
      (dired (cons default-directory files))))
#+end_src

** Journaling
#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (straight-use-package 'denote-journal)
  (setq denote-journal-directory (concat denote-directory "/journal"))
  (add-to-list 'denote-dired-directories denote-journal-directory)
  ;; calendar integration
  (require 'denote-journal)
  (add-hook 'calendar-mode-hook #'denote-journal-calendar-mode)
#+end_src

** Silos
Silos are a way to fully sepparate notes from each other. In order
to fully support them, we'll need to tell denote where each silo
lives.

#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (straight-use-package 'denote-silo)
  ;; (setq denote-silo-directories '())
  ;; (let ((my-silo-dirs (mapcar (lambda (file)
  ;;                               (expand-file-name file))
  ;;                             '("~/Dropbox/org/gtd/projects"))))
  ;;   (dolist (dir my-silo-dirs)
  ;;     (add-to-list 'denote-silo-directories dir)
  ;;     (add-to-list 'denote-dired-directories dir)))
#+end_src

** Hooks
#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
#+end_src

** Org integration
#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (straight-use-package 'denote-org)
#+end_src

** Sequences
Denote has optional support for sequences of notes, making
hierarchical series of notes with parent, child, sibling
relationships.

This sequence information is encoded in the denote [[denote:20231121T144329][File Naming Scheme]]
in the [[denote:20231205T093346][signature]] section.

#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (straight-use-package 'denote-sequence)
#+end_src
** Denote Explore
Denote explore is a great little package that supplies some helper
function meant to aid in managing your denote notes.

It is separated into four categories:

1. statistical information about your notes
2. random walks to help spur creative thinking about your notes
3. janitorial tasks to organize and clean up your notes
4. visualization methods to see the relationships between your notes

see [[info:denote-explore][here]] for a full manual on the package

#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (straight-use-package 'denote-explore)
#+end_src

** Consult Denote
#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (straight-use-package 'consult-denote)
  (consult-denote-mode 1)
#+end_src
** Templates
Denote allows for defining templates when creating a new note. The
selected template will pre-fill the newly created note.

#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (setq denote-templates
        `((onboarding . ,(concat "* Onboarding Tasks\n"
                                 "  - [ ] Welcome, office tour\n"
                                 "  - [ ] Get laptop (Ada)\n"
                                 "  - [ ] Kipsu Platform Architecture\n"
                                 "    - https://kipsudev.atlassian.net/wiki/spaces/EN/pages/3145105581/-+Architecture\n"
                                 "  - [ ] Set up local environment\n"
                                 "  - [ ] Get peripherals\n"
                                 "  - [ ] PagerDuty Access\n"
                                 "  - [ ] Account access\n"
                                 "    - AUDIT ticket\n"
                                 "    - github\n"
                                 "    - aws\n"
                                 "    - jira\n"
                                 "    - confluence"))
          (journal . ,(concat "* Daily habits\n"
                              "  - [[denote:20250423T155338][Be Still and Wonder]]\n"
                              "  - [[https://github.com/issues/SSC_kgDOABqApA?q=is%3Apr%20org%3AKipsu%20state%3Aopen%20archived%3Afalse%20sort%3Aupdated-desc%20-is%3Adraft%20review-requested%3A%40me][review pull requests]]\n\n"
                              "* Notes\n"))
          (person . ,(concat "* Relationships\n\n"
                             "* Prayer requests\n\n"
                             "* Meetings\n"))))
#+end_src
** Provide the module
#+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
  (provide 'my-denote)
#+end_src

* Dired

The Dir(ectory) Ed(itor). [[elisp:(info "(emacs) Dired")][Dired]] is a text based file manager, baked into
emacs. It uses the modest [[man:ls][ls]] command to generate the directory listing,
and adds a ton of functionality on top, allowing for inteligent commands
to operate on the seleted file(s). This only scratches the surface of
what it can do, so seriously, read the info doc.

** Settings

#+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
  (setq dired-kill-when-opening-new-dired-buffer t) 
  (require 'dired)
  (setq dired-listing-switches "-hAl")
  ;; this pre-fills the destination prompt of copy and rename
  ;; commands with the directory of the other dired buffer
  ;; if one is open. Very handy
  (setq dired-dwim-target t)

  ;; don't show all the file details by default
  ;; They're still accessible with '('
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src

I want to be able to toggle the display of dotfiles in dired. This function allows me to
do exactly that.

#+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
  (defun dired-dotfiles-toggle ()
    (interactive)
    (when (equal major-mode 'dired-mode)
      (if (or (not (boundp 'dired-dotfiles-show-p)) dired-dotfiles-show-p)
          (progn
            (set (make-local-variable 'dired-dotfiles-show-p) nil)
            (message "h")
            (dired-mark-files-regexp "^\\\.")
            (dired-do-kill-lines))
        (progn (revert-buffer)
               (set (make-local-variable 'dired-dotfiles-show-p) t)))))

  (keymap-set dired-mode-map "." #'dired-dotfiles-toggle)

  (defun dired-mark-files-extension (extension)
    "Mark all files with the given file EXTENSION.

   EXTENSION should not contain the . prefix.
   When called interactively, derive the extension from the current file
   under the point in the dired buffer."
    (interactive
     (list (if current-prefix-arg
               (read-string "Extension: ")
             (file-name-extension (dired-get-filename))))
     'dired-mode)
    (dired-mark-files-regexp (concat "." extension "$")))
#+end_src
** Bindings

#+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
  (keymap-set dired-mode-map "K" #'dired-do-kill-lines)
  (keymap-set dired-mode-map "h" #'dired-up-directory)
  (keymap-set dired-mode-map "l" #'dired-find-file)
  (defun dired-go-home ()
    (interactive)
    (dired-jump nil "~/"))
  (keymap-set dired-mode-map "~" #'dired-go-home)
#+end_src

** Helper functions
  
#+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
  (defun dired-first-file ()
    "Jump the point to the first dired entry that isn't . or .."
    (interactive)
    (beginning-of-buffer)
    (dired-next-line 1))

  (defun dired-last-file ()
    "Jump the point to the last dired entry."
    (interactive)
    (end-of-buffer)
    (dired-next-line -1))

#+end_src

** dired-preview

sometimes it's handy to preview the file under point as you're navigating
a directory. dired-preview allows for exactly this behavior.

#+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
  (straight-use-package 'dired-preview)
  (setq dired-preview-delay 0.2)
  #+end_src

** Icons

#+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
  (straight-use-package 'all-the-icons-dired)
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
  (setq all-the-icons-dired-monochrome nil)
#+end_src

** Provide the module

#+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
  (provide 'my-dired)
#+end_src
  
* GPG (egp)

GPG allows you to easily encrypt/decrypt files with either symmetric
(shared key) or asymetric (private key) encryption.

Emacs hooks into this seemlessly by automatically decrypting encrypted
files automatically when opening them using any loaded encyption keys
you have on the system.

** Disable waiting for status

There is an outstanding bug in epg where waiting for the enryption status
will hang, which blocks the whole editor. We can disable this for now.

#+begin_src emacs-lisp :tangle "my-modules/my-gpg.el" :mkdirp yes
  (fset 'epg-wait-for-status 'ignore)
#+end_src

** PIN entry

PIN entry is used to authorize a gpg key for use. By default emacs will
reach out to an external proccess to prompt for the PIN. But this is
emacs, let's make emacs do it.

#+begin_src emacs-lisp :tangle "my-modules/my-gpg.el" :mkdirp yes
  (setq epg-pinentry-mode 'loopback)
#+end_src

** Provide the module
  
#+begin_src emacs-lisp :tangle "my-modules/my-gpg.el" :mkdirp yes
  (provide 'my-gpg)
#+end_src

* Http server (simple-httpd)
This allows emacs to spin up a local http server to serve local
files on the filesystem.

** Add the package
#+begin_src emacs-lisp :tangle "my-modules/my-http.el" :mkdirp yes
  (straight-use-package 'simple-httpd)
#+end_src

** Provide the module

#+begin_src emacs-lisp :tangle "my-modules/my-http.el" :mkdirp yes
  (provide 'my-http)
#+end_src

* Epub support
** Load nov mode and associate it with .epub files
#+begin_src emacs-lisp :tangle "my-modules/my-epub.el" :mkdirp yes
  (straight-use-package 'nov)
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+end_src

** Provide the module
#+begin_src emacs-lisp :tangle "my-modules/my-epub.el" :mkdirp yes
  (provide 'my-epub)
#+end_src

* Feed reader
We use the wonderful `elfeed` package to track and read feeds.

#+begin_src emacs-lisp :tangle "my-modules/my-feed.el" :mkdirp yes
  (straight-use-package 'elfeed)
  (setq elfeed-feeds
        '(("https://protesilaos.com/codelog.xml" code emacs)
          ("http://rss.desiringgod.org/" christianity)
          ("https://karthinks.com/index.xml" emacs)
          ("https://www.thegospelcoalition.org/feed/" christianity)
          ("https://www.firstthings.com/rss/web-exclusives" christianity)
  		("https://irreal.org/blog/?feed=rss2" emacs)))

  (provide 'my-feed)
#+end_src
    
* Programming
#+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
  (setq-default tab-width 4)
#+end_src
** Prog mode
Emacs has a general ~prog~ mode, serving as the base major mode for
all language specific programming modes. Adding settings and hooks
for this mode means they will be set for all programming languages.

*** Rainbow delimiters
   
Highlight netsted delimeters with unique colors so you can tell
at a glance how deep you are.


#+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
  (straight-use-package 'rainbow-delimiters)
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+end_src

*** LSP (Language Server Protocol)
#+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
  (straight-use-package 'lsp-mode)
  (straight-use-package 'lsp-ui)
#+end_src
*** Eglot

   Language server client implimentation. Comes baked into emacs starting
   at version 29.

   There seems to be a bug with the latest version of `menu-bar' (maybe?
   or perhaps in `project'?)

   Eglot attempts to insert itself info the menu bar, but the project
   entry in the menu bar is not defined. Setting this variable to ~nil~
   resolves the immediate issue causing ~eglot~ to crash. It is unknown
   what downstream ramifications this actually causes.

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (defvar menu-bar-project-menu '())
   #+end_src

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (add-hook 'eglot-managed-mode-hook
               (lambda ()
                 (setq eldoc-documentation-strategy #'eldoc-documentation-compose)
                 (setq eldoc-documentation-functions
                       '(eglot-signature-eldoc-function
                         eglot-hover-eldoc-function))))
   #+end_src

   And for support for languages that aren't pre-configured out of
   the box by eglot:

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (with-eval-after-load 'eglot
       (add-to-list 'eglot-server-programs
		    `(terraform-mode . ("terraform-ls" "serve"))))
   #+end_src

*** Highlight TODO statements

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (straight-use-package 'hl-todo)
     (global-hl-todo-mode 1)
   #+end_src
*** Electric pair mode
   This is a fairly simple mode that automatically inserts the matching symbol. =)= after typing =(=
   for instance.

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (electric-pair-mode 1)
   #+end_src
*** Provide =my-prog-mode=
   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (provide 'my-prog-mode)
   #+end_src
    
** Flycheck (error checking)
This replaces the venerable, but outdated flymake.

#+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
  ;; need to set some flymake variable that aparently needs to be in scope
  (setq flymake-allowed-file-name-masks nil)
  (straight-use-package 'flycheck)
  (global-flycheck-mode 1)
#+end_src

** Flyover (inline diagnostics)
#+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
  ;; (straight-use-package '(flyover
  ;;                         :type git
  ;;                         :host github
  ;;                         :repo "konrad1977/flyover"))
  ;; (add-hook 'flycheck-mode-hook #'flyover-mode)
  ;; (setq flyover-levels '(error warning info))
#+end_src

** Tree Sitter
*** Overview
    Tree sitter allows for parsing structured text formats into an
    abstract syntax tree. From there, it provides language agnostic
    methods to find and modify the AST. Having the parse tree allows
    for far more consistent and robust syntax highlighting, but beyond
    that, it will allow for structured text editing which operates at
    the level of syntactical objects rather than characters.

*** Install the package
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (straight-use-package 'tree-sitter)
      (straight-use-package 'tree-sitter-indent)
      (straight-use-package 'tree-sitter-langs)
    #+end_src

*** Install languages
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (setq treesit-language-source-alist
	    '((rust "https://github.com/tree-sitter/tree-sitter-rust")
	      (typst "https://github.com/uben0/tree-sitter-typst")))

      (setq treesit-load-name-override-list '((rust "libtree-sitter-rust" "tree_sitter_rust")))
    #+end_src

*** Enable global tree sitter mode
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (global-tree-sitter-mode)
      (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
    #+end_src

*** Provide the module
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (provide 'my-tree-sitter)
    #+end_src
** Rest mode
   Run http commands using simple http spec

   #+begin_src emacs-lisp :tangle "my-modules/my-rest-mode.el" :mkdirp yes
     (straight-use-package 'restclient)
     (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode))
     (provide 'my-rest-mode)
   #+end_src
 
** Docker support
*** Dockerfile mode

#+begin_src emacs-lisp :tangle "my-modules/my-docker-mode.el" :mkdirp yes
  (straight-use-package 'dockerfile-mode)
#+end_src
*** docker integration

This package allows for intuitive, magit-like interaction with docker:
images, containers, compose, and more.

 #+begin_src emacs-lisp :tangle "my-modules/my-docker-mode.el" :mkdirp yes
   (straight-use-package 'docker)
   (keymap-global-set "C-c d" #'docker)
 #+end_src

*** Provide the module
 #+begin_src emacs-lisp :tangle "my-modules/my-docker-mode.el" :mkdirp yes
   (provide 'my-docker-mode)
 #+end_src

** Lisp modes
*** Indentation
   #+begin_src emacs-lisp :tangle "my-modules/my-lisp-mode.el" :mkdirp yes
     (straight-use-package 'aggressive-indent)
     (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
     (provide 'my-lisp-mode)
   #+end_src
** Markup languages
*** Markdown
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'markdown-mode)
   #+end_src

*** Json
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'json-mode)
   #+end_src

*** Yaml 
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'yaml-mode)
     (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))
   #+end_src
*** Json
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'json-mode)
   #+end_src
*** Provide =my-markup=
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (provide 'my-markup)
   #+end_src
** Terraform 
*** Install the package
   #+begin_src emacs-lisp :tangle "my-modules/my-terraform-mode.el" :mkdirp yes
     ;; -*- lexical-binding: t; -*-
     (straight-use-package 'terraform-mode)
     (provide 'my-terraform-mode)
   #+end_src

*** Settings
   #+begin_src emacs-lisp :tangle "my-modules/my-terraform-mode.el" :mkdirp yes
     (setq terraform-format-on-save t)
   #+end_src

*** Bindings
   #+begin_src emacs-lisp :tangle "my-modules/my-terraform-mode.el" :mkdirp yes
     (defun terraform-init ()
       (interactive)
       (compile "terraform init"))

     (defun terraform-plan ()
       (interactive)
       (compile "terraform plan"))

     (defun terraform-apply ()
       (interactive)
       (compile "terraform apply"))
   #+end_src

*** Provide my-terraform
   #+begin_src emacs-lisp :tangle "my-modules/my-terraform-mode.el" :mkdirp yes
     (provide 'my-terraform-mode)
   #+end_src

** PHP

   Configure eglot to use inteliphense

   *This doesn't work currently. not sure what's wrong with intelephense*
   #+begin_src emacs-lisp :tangle "my-modules/my-php-mode.el" :mkdirp yes
     ;; (with-eval-after-load 'eglot
     ;;   (add-to-list 'eglot-server-programs
     ;;	    '(php-mode . ("intelephense" "--stdio"))))
     (straight-use-package 'php-mode)
     (provide 'my-php-mode)
   #+end_src

** Python
*** Pipfile support
    #+begin_src emacs-lisp :tangle "my-modules/my-python-mode.el" :mkdirp yes
      (add-to-list 'auto-mode-alist '("Pipfile" . conf-toml-mode))
    #+end_src
*** Provide =my-python-mode=
    #+begin_src emacs-lisp :tangle "my-modules/my-python-mode.el" :mkdirp yes
      (provide 'my-python-mode)
    #+end_src

** Rust
   #+begin_src emacs-lisp :tangle "my-modules/my-rust-mode.el" :mkdirp yes
     (straight-use-package 'rust-mode)
     (setq rust-format-on-save t)
     (add-hook 'rust-mode-hook
     		  (lambda () (prettify-symbols-mode)))
     (provide 'my-rust-mode)
   #+end_src

** Vimrc

  This adds syntax highlighting for the random times I'll need to edit
  a vimrc-esque file from emacs.

  #+begin_src emacs-lisp :tangle "my-modules/my-vim-mode.el" :mkdirp yes
    ;; -*- lexical-binding: t; -*-

    (straight-use-package 'vimrc-mode)
    (provide 'my-vim-mode)
  #+end_src

** Nushell
   This adds support for nushell files

   #+begin_src emacs-lisp :tangle "my-modules/my-nushell-mode.el" :mkdirp yes
     (straight-use-package 'nushell-mode)
     (provide 'my-nushell-mode)
   #+end_src
** Golang
   #+begin_src emacs-lisp :tangle "my-modules/my-go-mode.el" :mkdirp yes
     (straight-use-package 'go-mode)
     (setq gofmt-command "/usr/local/go/bin/gofmt")
     (setenv "PATH"
             (concat
              "/usr/local/go/bin:"
              "/Library/TeX/texbin:"
              "/opt/homebrew/bin:"
              (getenv "PATH")))
     (defun my-go-mode-hook ()
       (when (eq major-mode 'go-mode)
         (gofmt-before-save)))
     (add-hook 'before-save-hook #'my-go-mode-hook)
     (provide 'my-go-mode)
   #+end_src
** Neon mode
Neon mode is mostly just yaml.

#+begin_src emacs-lisp :tangle "my-modules/my-neon-mode.el" :mkdirp yes
  (straight-use-package 'neon-mode)
  (provide 'my-neon-mode)
#+end_src
* Org

  What is org mode? What /isn't/ org mode? Built on top of emacs' outline-mode, org mode
  poorly documented extras, but all baked in and then some) It can make headings, lists,
  emphasize text, store links to other headings in the same or different files and so
  much more.

  In addition to note taking, it handles thinks like task tracking, scheduling, effortless
  ascii table editing, embedded runnable code snippets (think Jupyter notebooks).

  In fact, this emacs configuration is written in org mode, and the embedded emacs lisp
  is extracted and ran to formulate the actual config.

  #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
    (straight-use-package '(org :type built-in))
    (require 'org)
  #+end_src

** modules
   As if org wasn't useful enough as it was, it also ships with a bunch of
   additional modules that add additional features. Check it out by looking
   at the customize-option for [[elisp:(customize-option 'org-modules)][org-modules]]. One useful one added here is
   the ~man~ module, which provides support for linking to man pages (opened
   in emacs' built in man page viewer, obviously)

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (with-eval-after-load 'org
       (require 'ol-man)
       (add-to-list 'org-modules 'ol-man t)
       (add-to-list 'org-modules 'org-habit t))
   #+end_src

** Settings
*** org tempo
    Org tempo does a lot, I should really look into more of what it has to offer.
    At the very least, I use it for really handy expansion for scr blocks.
    I can type =<s= and hit =TAB= to expand it to =#+begin_src=.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (with-eval-after-load 'org
       (require 'org-tempo))
   #+end_src

*** default files and directories

   These are a handful of settings that set up default destinations for actions that
   act globally, such as [[*Org capture][org-capture]].

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-directory "~/Dropbox/org/gtd/")
     (setq org-default-notes-file "~/Dropbox/org/gtd/gtd.org")
   #+end_src

*** todo statuses

   Setting todo states
   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-todo-keywords
           '((sequence
              "TODO(t)"
              "NEXT(n)"
              "WAIT(w)"
              "STRT(s)"
              "BLOCKED(b)"
              "REVIEW(r)"
              "|"
              "DONE(d)"
     		 "CANCELED(c)")))
   #+end_src
   
*** images

   When inserting images in org files, often they will be way to large to fit into
   the general flow of the document. Through the use of ~#+attr_html: :width NNpx~,
   you cen set how large the image should be displayed as. To enable this, we will
   need to turn off the following setting.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-image-actual-width nil)
   #+end_src

*** indentation

   messing with org src block indentation

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-src-preserve-indentation nil)
     (setq org-startup-indented t)
     (straight-use-package
      '(org-modern-indent
        :type git
        :host github
        :repo "jdtsmith/org-modern-indent"))
     (require 'org-modern-indent)
     (add-hook 'org-mode-hook #'org-modern-indent-mode 90)
   #+end_src

*** display settings
   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-hide-emphasis-markers t)
   #+end_src

*** Priority

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-priority-highest ?A
     	  org-priority-lowest ?D)
   #+end_src

*** export
Org can export content into a variety of formats.  Most relevant to my
purposes is LaTeX/pdf.  What follows are various settings specific to
configuring the environment for exporting org documents into TeX and
then into pdfs

#+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
  ;; for handling CSL citation languages in org exporting to latex
  (straight-use-package 'citeproc)

  ;; use latexmk for generating pdfs from tex files
  (setq org-latex-pdf-process '("LC_ALL=en_US.UTF-8 latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

With the ~ox-typst~ package, org can export to typst documents.

#+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
  (with-eval-after-load 'org
    (straight-use-package 'ox-typst)
    (require 'ox-typst))
#+end_src


** Org agenda
*** Custom commands
    These commands show up in the org-agenda view and will produce
    lists of org headings matching a variety of criteria.
#+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
  (setq org-agenda-custom-commands
  	  '(("g" "GTD Review"
  		 ((tags "+proj+LEVEL=2"
  				((org-agenda-overriding-header "Active Projects")))
  		  (todo "STRT"
  				((org-agenda-overriding-header "In Progress")))
  		  (todo "WAIT|REVIEW|BLOCKED"
  				((org-agenda-overriding-header "Waiting...")))
  		  (todo "NEXT"
  				((org-agenda-overriding-header "Next Actions")))
  		  (tags "+DEADLINE=\"\"+SCHEDULED=\"\"+TODO=\"TODO\"|TODO=\"WAIT\""
  				((org-agenda-overriding-header "Inactive tasks")))))

  		("d" "GTD Daily View"
  		 ((agenda ""
  				  ((org-agenda-overriding-header "Today")
  				   (org-agenda-span 1)))
  		  (todo "STRT"
  				((org-agenda-overriding-header "In Progress")))
  		  (todo "WAIT|REVIEW|BLOCKED"
  				((org-agenda-overriding-header "Waiting...")))
  		  (todo "NEXT"
  				((org-agenda-overriding-header "Next Actions")))))))
#+end_src

*** agenda view settings
#+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
	(setq org-agenda-time-grid
		  '((daily today require-timed remove-match)
			(800 1000 1200 1400 1600 1800 2000)
			"  "
			""))
#+end_src

*** Stuck projects

A stuck project is a project which has no identified "next"
action on it. Using my "getting things done" system, this means a
project is one which has the tag "proj" and a task with the
"NEXT" or "STRT" todo state.

#+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
  (setq org-stuck-projects
		'("+proj-archive+LEVEL=1/-DONE" ("NEXT" "STRT") nil ""))
#+end_src

*** basic settings
    Org agenda is cool. It tries to create a day/week/month planner out of any tasks
    or scheduled events it can find in `org-agenda-files'.

    I want it to pull in appointments or reminders from the diary as well since
    those sorts of events don't really make sense to track in org.

    This will cause emacs to save all the associated buffers attached
    to the headings shown in the agenda buffer.

    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (advice-add 'org-agenda-quit :before 'org-save-all-org-buffers)
    #+end_src

*** Refile targets

#+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
  (setq org-refile-targets
  	  '((org-agenda-files . (:regexp . "One Off"))
  		(org-agenda-files . (:regexp . "Events"))
  		(org-agenda-files . (:regexp . "Someday"))
  		(org-agenda-files . (:tag . "proj"))))
#+end_src

*** Tag list

These tags allow you to select from a list of these predefined tags
using single-key shortcuts (if provided) to toggle tags from a
heading.

#+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
  (setq org-tag-alist
        '((:startgroup)
          ("proj" . ?p)
          ("area" . ?a)
          (:endgroup)

          ;; mental/emotional level
          (:startgroup)
          ("@lowenergy" . ?l)
          ("@highenergy" . ?h)
          (:endgroup)

          ;; locations
          (:startgroup)
          ("@Church" . ?C)
          ("@Work" . ?W)
          ("@Transit" . ?T)
          ("@Home" . ?H)
          ("@Anywhere" . ?A)
          ("@Outsize" . ?O)
          (:endgroup)

          ;; devices
          (:startgroup)
          ("@Laptop" . ?L)
          ("@Phone" . ?P)
          (:endgroup)))

  (setq org-agenda-include-diary t)
  (setq org-agenda-restore-windows-after-quit t)
  (setq org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-category-icon-alist nil)
  (setq org-columns-default-format "%TODO %3PRIORITY %45ITEM %16SCHEDULED %TAGS")
  (add-to-list 'org-agenda-category-icon-alist
               '(".*" '(space . (:width (18)))))

  (add-to-list 'org-agenda-files org-directory)
#+end_src

*** super agenda
    NOTE: this package recipe appears to be broken
    currently. Something about the version of org is wrong.

	*NOTE*: Maybe since I pinned the org version to the local one this
     should work better?
    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      ;; (straight-use-package 'org-super-agenda)
      ;; (setq org-super-agenda-groups
      ;; '(
      ;; 	(:name "Today"
      ;; 	       :time-grid t
      ;; 	       :todo '("TODO" "WORKING"))))
    #+end_src

** Org capture

   Org capture aids you in jotting down a quick note when you think of somethimg
   you want to remember but don't want to lose momentum in whatever task you
   were in the middle of.

   Say you were writing a new feature in an application and you realize there's
   a possibility to refactor an adjacent part of the code. Run org capture
   M-x [[help:org-capture][org-capture]] and a temporary buffer opens up where you can take your
   note. It will automatically embed any contextual information about where
   you took the note from, such as which file you were editing, the time,
   etc. Once you finish the note, close the buffer with ~C-c C-c~ and the note
   is gone, the window closes and you're back to doing what you were doing
   before.

   Behind the scenes ~org-capture~ stored your note in the file of your choosing
   for you to review on your own time when convenient.

   You can customize what types of notes ~org-capture~ can take, so that you can
   capture any any data you want, place it into any file you want. Just customize
   the variable ~org-capture-templates~.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-capture-templates
     	  `(("i" "Inbox   - things that may need attention later" entry (file "~/Dropbox/org/gtd/inbox.org")
              "* %?\n/Entered on/ %U")
     		("p" "Project - new project" entry
     		 (file+headline org-default-notes-file "Projects")
     		 "* %^{project title} %(org-set-tags \"proj\")\n** Notes\n\n** Tasks\n*** TODO %?")))
   #+end_src

** Org structures
   Org supports a variety of /structures/. In context, a structure is a block of
   content. Structures can contain source code, comments, quotes, examples, and
   more.

   This can be extended through ~org-structure-template-alist~.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-structure-template-alist
           '(("s" . "src")
             ("e" . "src emacs-lisp")
             ("b" . "src bash")
     		("q" . "quote")
             ("t" . "src emacs-lisp :tangle FILENAME :mkdirp yes")))
   #+end_src
** Org publish

   Org allows you to export any org file to a variety of formats:
     - markdown
     - iCalendar (for scheduled/deadline events)
     - ODT (or word if configured) documents
     - plain text (using unicode or ascii elemets)
     - html

   Beyond this however, you can configure org to publish a whole collection
   of org files into a viewable site. It will configure links, css, and more
   for you. You just need to configure the projects variable

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (require 'ox-publish)

     (setq org-publish-use-timestamps-flag nil)

     ;; Don't show validation link
     (setq org-html-validation-link nil)
     ;; Use our own scripts
     (setq org-html-head-include-scripts nil)
     ;; Use our own styles
     (setq org-html-head-include-default-style nil)

     ;; this allows us to get syntax highlighting in source blocks exported to html
     (straight-use-package 'htmlize)

     (setq org-publish-project-alist
       (list (list "blog"
               :components (list "blog-org" "blog-static"))
         (list "blog-org"
               :base-directory "~/blog/org"
               :publishing-directory "~/blog/public"
               :auto-sitemap nil
               :recursive t
               :with-broken-links t
                       :with-creator t
               :section-numbers nil
               :exclude "README"
               :export-exclude-tags (list "draft")
               :with-author "Jon Harder"
               :with-toc nil
               :html-htmlize-output-type 'inline-css
               :html-doctype "html5"
               :html-html5-fancy t
               :html-preamble nil
               :html-postamble nil)
         (list "blog-static"
               :base-directory "~/blog/org/"
               :base-extension "css\\|ico\\|png\\|jpg\\|jpeg\\|gif"
               :publishing-directory "~/blog/public/"
               :recursive t
               :publishing-function #'org-publish-attachment)))
   #+end_src

** Visual enhancements

*** Emphasis markers

    Hide the markers which annotate different emphasis indicators in text.

    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (setq org-hide-emphasis-markers t)
    #+end_src

*** Org Modern

~org-modern~ uses emacs built-in text properties to style org elements
in a beautiful way. It incapsulates ~org-bullets~ and thus that
package is disabled.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (straight-use-package 'org-modern)
     (with-eval-after-load 'org (global-org-modern-mode))
   #+end_src

** Babel

   Org babel is a code embedding feature. It comes included in the default
   install of Org (which itself comes with emacs core).

   Every emacs-lisp block in this file is written in a source block that
   babel will evaluate to form the actual, runnable config.

   This is how [[file:init.el][init.el]] can be just one sexp; telling babel to untangle
   this file in order to extract all the elisp.

   It's far more powerfull than that though, as it allows for [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]]
   in the style of Jupyter notebooks. You can execute a bash script, record the
   results, then feed that data into a python script and export that into an org
   table. This is a huge boon to reproducible research, and documenting processes.

   In order to execute code snippets in an org buffer, that language must be supported
   and enabled. By default, org only authorizes emacs-lisp, but this can be easily
   changed using ~org-bable-do-load-languages~. Your language of choice might not be
   supported out of the box, even if you add it using ~org-babel-do-load-languages~;
   if this is the case, you'll need to load a third-party package to support it.
   These are typically called =ob-$LANG=. For example, to support executing haskell,
   you must install the package =ob-haskell=.

*** Enabling more languages

     #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (python . t)
          (calc . t)
          (shell . t)))
     #+end_src

** toc-org

   Toc org is a package that dynamically generates and maintains a table
   of contents within org documents.

   All you need to do is annotate any heading with ~:TOC:~ and the plugin
   will highjack that heading for use on save.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (straight-use-package 'toc-org)
     (add-hook 'org-mode-hook 'toc-org-mode)
#+end_src

** Literate calc mode
   Literate calc mode evaluations equations inline in your buffer and
   prints the results as overlays in the file.

   Using its minor mode in org results in a really ergonomic
   experience with hashing out quick equations.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (straight-use-package 'literate-calc-mode)
     (add-hook 'org-mode-hook #'literate-calc-minor-mode)
   #+end_src
   
** Provide =my-org=
   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (provide 'my-org)
   #+end_src
* Jujutsu (jj)
   Jujutsu in a simple, but powerful version control system. It's
   great. It uses git as the backing change database (though a native,
   novel storage backend is in the works) so it can be seamlessly used
   in a git based project and even used alongside with other
   contributors who are still using git directly.

   #+begin_src emacs-lisp :tangle "my-modules/my-jj.el" :mkdirp yes
     (straight-use-package
      '(jj-mode :type git
                :host github
                :repo "bolivier/jj-mode.el"))
     (require 'magit)
     (provide 'my-jj)
   #+end_src
* Search
** Isearch
    There are a variety of entrypoints into emacs' built in searching
    facilities.

    The most basic and straightforward is ~isearch-forward~, bound to
    =C-s= by default.

*** Settings
     #+begin_src emacs-lisp :tangle "my-modules/my-search.el" :mkdirp yes
       ;; -*- lexical-binding: t; -*-
       (setq isearch-lazy-count t
             lazy-count-prefix-format "(%s/%s) "
             lazy-count-suffix-format nil)
     #+end_src
** Provide =my-search= module
   #+begin_src emacs-lisp :tangle "my-modules/my-search.el" :mkdirp yes
     (provide 'my-search)
   #+end_src

* Shells
** Basic config

   This sets which shell to use when executing commands from dired or compile and friends
   This is different from the shell to use in interactive sessions.

   Because I use [[https://www.nushell.sh][nushell]] for my shell, regular commands like [[man:find][find]] often choke when tools
   like dired assume the posix implementation.

   #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
     ;; -*- lexical-binding: t; -*-
     (setq explicit-shell-file-name "/opt/homebrew/bin/nu"
           shell-file-name "/bin/zsh")
   #+end_src

** Eshell
*** Environment variables
    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (setenv "GITHUB_KEY" "/Users/jharder/.ssh/docker_github")
      (add-to-list 'exec-path "/usr/local/go/bin")
      (add-to-list 'exec-path "/opt/homebrew/bin")
      (add-to-list 'exec-path "/Library/TeX/texbin")
      (add-to-list 'exec-path "/Users/jharder/.rustup/toolchains/stable-aarch64-apple-darwin/bin")
    #+end_src

*** hook
    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (add-hook 'eshell-mode-hook
                (lambda ()
                  (setenv "TERM" "eterm")
                  (setenv "PAGER" "cat")))

    #+end_src
*** Settings

    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (require 'eshell)
      (add-to-list 'eshell-modules-list 'eshell-smart)

      (straight-use-package 'eshell-syntax-highlighting)
      (require 'eshell-syntax-highlighting)
      (eshell-syntax-highlighting-global-mode +1)

      ;; (require 'em-smart)
      ;; (setq eshell-where-to-jump 'begin)
      ;; (setq eshell-smart-space-goes-to-end nil)

      ;; (setq eshell-review-quick-commands nil)
      (require 'em-term)

      (setq eshell-visual-commands
            '("vi"
              "vim"
              "hx"
              "screen"
              "nvim"
              "bacon"
              ;; "gh"
              "tmux"
              "top"
              "htop"
              "less"
              "more"
              "lynx"
              "links"
              "ncftp"
              "mutt"
              "pine"
              "tin"
              "trn"
              "elm"))

      (setq eshell-visual-subcommands
            '(("jj" "squash" "split")))
    #+end_src

*** Completion

    I want more intelligent completion in eshell.

    This provides smart docker completion, not only for available
    subcommands, but also for realtime completion of available
    images in particular for commands like `run'. 

    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (defconst pcmpl-docker-commands
        '("run" "exec" "ps" "build" "pull" "images" "login" "logout"
          "search" "version" "info"
          "compose"))

      (defvar docker-images-command "docker image ls | tail -n +2 | awk '{ if($1 != \"<none>\") { if($2 == \"<none>\") { print $1 } else { printf(\"%s:%s\\n\", $1, $2) } } }'")
      (defun pcmpl-docker-images ()
        (let ((results (shell-command-to-string docker-images-command)))
          (string-split results "\n")))

      (defun pcomplete/docker ()
        "Completion for `docker'."
        (pcomplete-here* pcmpl-docker-commands)
        (cond
         ((pcomplete-match (regexp-opt '("run")) 1)
          (pcomplete-here* (pcmpl-docker-images)))))

    #+end_src
*** Custom functions
    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (require 'eshell)
      (require 'esh-mode)

      (defun eshell/p ()
        (interactive)
        (eshell/pwd))

      (defun eshell/less (file)
        "Use `view-file' instead of less when viewing FILE."
        (interactive)
        (view-file file))

      (defun eshell/f (&optional file)
        "Shorthand for `find-file', opening FILE."
        (interactive)
        (if file
            (find-file file)
          (call-interactively #'find-file)))

      (defun eshell/d (&optional dir)
        "Run `dired' for directory DIR, or current dir if not given."
        (interactive)
        (if dir (dired dir) (dired ".")))

      (defun eshell/q ()
        "Kill the `eshell' process and close its window."
        (interactive)
        (if (one-window-p)
      	  (switch-to-buffer nil)
      	(delete-window)))

      (defun eshell-here ()
        "Open an `eshell' window relative to the active buffer's file."
        (interactive)
        (let* ((parent (if (buffer-file-name)
                           (file-name-directory (buffer-file-name))
                         default-directory))
               (name (car (last (split-string parent "/" t))))
               (buffer-name (concat "*eshell: " name "*")))
          (if-let* ((buffer (get-buffer buffer-name)))
              (progn
                (display-buffer buffer)
                (switch-to-buffer buffer))
            (eshell "new")
            (rename-buffer (concat "*eshell: " name "*"))
            (insert "ls")
            (eshell-send-input))))

    #+end_src
*** Prompt
Because eshell is just elisp, the prompt can be set using elisp as well.
This unlocks the full power of emacs as an environment and can be harnesed
to make eshell as fancy as you can dream up (and program)

#+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
  (setq eshell-prompt-function
        (lambda ()
          (let* ((home-path (getenv "HOME"))
                 (dir (string-replace home-path "~" (eshell/pwd)))
                 (branch nil)) ; (magit-get-current-branch)))
            (concat
             (propertize dir 'face `(:foreground "#61bfff"))
             (if branch
                 (concat (propertize " on \uE0A0 " 'face `(:foreground "white"))
                         (propertize branch 'face `(:foreground "green")))
               "")
             " $ "))))

  (setq eshell-prompt-regexp ".*$ ")
#+end_src
** Eat
  [[https://codeberg.org/akib/emacs-eat][Eat]] is a new kind of shell for emacs, handling fully interactive, fullscreen terminal apps
  cleanly. I think it can replace vterm, and has the benefit of not needing system
  dependencies nor a compilation step.

  #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
    (straight-use-package 'eat)
  #+end_src
** Vterm

   #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
     (straight-use-package 'vterm)
     (straight-use-package 'multi-vterm)
     (setq vterm-shell "/opt/homebrew/bin/nu")
   #+end_src
** Provide =my-shells=
   #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
     (provide 'my-shells)
   #+end_src

* Typst
    Typst is great. It's a modern and easy to use reimagining of LaTeX.

** Install package
    #+begin_src emacs-lisp :tangle "my-modules/my-typst.el" :mkdirp yes
      ;; -*- lexical-binding: t; -*-
      (straight-use-package
       '(typst-ts-mode
         :type git
         :host sourcehut
         :repo "meow_king/typst-ts-mode"
         :custom
         (typst-ts-mode-watch-options "--open")))
    #+end_src

** Provide feature =my-typst=
    #+begin_src emacs-lisp :tangle "my-modules/my-typst.el" :mkdirp yes
      (provide 'my-typst)
    #+end_src
 
* Navigation
** Windows
*** Winner mode

winner mode allows you to move back in time to prior window
configurations, though it is a mode that must be enabled in order to
record window configurations.

#+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
  (winner-mode 1)
#+end_src

*** ace-window

    Ace window is a handy way to supercharge `other-window' by giving
    each option a lettered target. Simply pressing that letter jumps
    straight to the targeted window, without having to cycle through
    any intermediate windows in the cycle.

    #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
      (straight-use-package 'ace-window)
      (setq aw-keys '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
    #+end_src

*** Window management

    Window management in emacs is very powerful, but oft misunderstood.
    Here are some rules to inform emacs of where I want particular windows
    to go.

    #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
      (setq switch-to-buffer-obey-display-actions t)

      (add-to-list 'display-buffer-alist
                   '("\\*eshell.*\\*"
                     (display-buffer-at-bottom)
                     (side . bottom)
                     (slot . 0)
                     (window-height . .50)))

      ;; (add-to-list 'display-buffer-alist
      ;;              '("\\*vterm.*\\*"
      ;;                (display-buffer-at-bottom)
      ;;                (side . bottom)
      ;;                (slot . 0)
      ;; (window-height . .50)))

      (add-to-list 'display-buffer-alist
                   '("Calendar"
                     (display-buffer-below-selected)
                     (window-height . .20)))
    #+end_src

Growing, shrinking, and moving windows is a fairly common task, yet
usually involves resorting to the mouse, or performing a long series
of keyboard commands to perform the desired action solely through the
keyboard.  Using emacs' transient maps, we can create our own little
sub-mode with a persistent map.  This map defines some purpose-driven
commands around manipulating windows, and as soon as a key not in the
map is pressed, it exits the transient map and fires off the normal
command for the key as usual.

#+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
  (defun window-management-mode ()
    "Manipulate windows (size, location, number, etc)."
    (interactive)
    (let ((transient-keymap (make-sparse-keymap)))
      (define-key transient-keymap (kbd "j") (lambda ()
                                               (interactive) (enlarge-window 3)))
      (define-key transient-keymap (kbd "k") (lambda ()
                                               (interactive) (shrink-window 3)))
      (define-key transient-keymap (kbd "h") (lambda ()
                                               (interactive) (shrink-window-horizontally 3)))
      (define-key transient-keymap (kbd "l") (lambda ()
                                               (interactive) (enlarge-window-horizontally 3)))
      (define-key transient-keymap (kbd "v") #'split-window-right)
      (define-key transient-keymap (kbd "s") #'split-window-below)
      (define-key transient-keymap (kbd "c") #'delete-window)
      (define-key transient-keymap (kbd "o") #'delete-other-windows)
      (define-key transient-keymap (kbd "w") #'other-window)
      (define-key transient-keymap (kbd "L") #'evil-window-right)
      (define-key transient-keymap (kbd "H") #'evil-window-left)
      (define-key transient-keymap (kbd "J") #'evil-window-down)
      (define-key transient-keymap (kbd "K") #'evil-window-up)

      (set-transient-map transient-keymap t nil "Window management keymap: [j]grow height, [k]shrink height, [l]grow width, [h]shrink width
  [w]other-window [J]window-down [K]window-up [H]window-left [L]window-right
  [v]vertical-split [s]split
  [c]close-window [o]close-others")
      (message "Window management transient keymap activated.")))
#+end_src

** Ace jump

  Ace jump is a fantastic package that allows you to jump to any point on the screen with 3
  key presses or less. It's like using your mouse to go wherever you need, but without
  moving your hands off the keyboard.

  #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
    (straight-use-package 'ace-jump-mode)
  #+end_src

** Provide =my-navigation=
  #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
    (provide 'my-navigation)
  #+end_src

* Web Browsing
** Convenience functions

   #+begin_src emacs-lisp :tangle "my-modules/my-web.el" :mkdirp yes
     (defun google-this (start end)
       "google-this googles either the selected region or the symbol at point.

     It makes use of the `browse-url' method which can be configured
     to query using a variety of tools.  By default, it will search
     using an external browser configured via the operating system."
       (interactive "rGoogle: ")
       (let ((query (if (region-active-p)
                        (buffer-substring start end)
                      (thing-at-point 'symbol t))))
         (browse-url (format "https://google.com/search?q=%s" query))))
   #+end_src
   
** Provide my-web

   #+begin_src emacs-lisp :tangle "my-modules/my-web.el" :mkdirp yes
     (provide 'my-web)
   #+end_src

* Email
** Mail server/client setup
  #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
    (setq send-mail-function 'smtpmail-send-it)
    (setq smtpmail-default-smtp-server "smtp.gmail.com"
          smtpmail-smtp-server "smtp.gmail.com"
          smtpmail-stream-type 'tls
          smtpmail-smtp-service 465
          user-mail-address "jharder@kipsu.com")
  #+end_src

** mbsync setup
At this point you shouldn't be surprised to find that emacs has decent support for sending
and receiving emails. It even has a mail retrieval utility built in, rmail.

This setup requires ~isync~ to be installed on the host machine (a.k.a. the vestigial
layer that separates emacs from the motherboard).

Google specific configuration/:
You will need an application password (create one [[https://myaccount.google.com/apppasswords][here]]). I store
For mbsync, I store this file here: [[file:~/gmail_app_pass.gpg]]. This
allows us to read mail from gmail for notmuch to index.
Save this value into a secure place, ideally encrypted. Emacs
supports gpg encryption out of the box, so this is a good option.

In order to send mail however, we need to have a record in:
[[file:~/.authinfo.gpg]] with a record for googles smtp server:

#+begin_src text
  machine smtp.gmail.com login your.email@example.com port 465 password YOUR_PASSWORD
#+end_src

This password must be the same as the app password created above and
stored previously.

NOTE*: as of [2023-10-16 Mon], there is a known issue with mbsync pulling from (at least for gmail)
remote inboxes. It runs for a time, then errors out with a socket error complaining about
an unexpected EOF. This has been patched, but is not yet in the homebrew formula, so we install
from =master=.

brew install --HEAD isync~

It also requires a mbsync configuration file to work correctly. [[file:~/.mbsyncrc][~/.mbsyncrc]]

** Notmuch
*** Meta: setup
from there just configure it

src_sh[]{notmuch setup}

and let notmuch index your mail

src_sh[]{notmuch new}
*** Require the project
#+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
  (straight-use-package 'notmuch)
#+end_src

*** Enable org links generated from notmuch
#+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
  ;; (straight-use-package 'ol-notmuch)
#+end_src

*** Configuring notmuch
**** Composing emails
#+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
  (defun my-notmuch-message-mode-hook ()
    (auto-fill-mode -1)
    (visual-line-mode 1))

    (add-hook 'notmuch-message-mode-hook #'my-notmuch-message-mode-hook)
#+end_src

**** Hello sections
    The following configures the "hello" (start) page of notmuch. This page is
    the default view when running the command ~notmuch~.

    This configures the sections on the hello page of notmuch. I don't like the
    header because it doesn't provide any useful information for me.

    I also remove the "recent searches" because these can be easily retrieved
    in buffer history when executing a search with =s=.

    #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
      (setq notmuch-hello-sections
	    '(notmuch-hello-insert-saved-searches
	      notmuch-hello-insert-search
	      notmuch-hello-insert-alltags
	      notmuch-hello-insert-footer))
    #+end_src

**** Saved searches

   #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
     (setq notmuch-saved-searches
	   '((:name "attachments" :query "tag:attachment" :key "a")
	     (:name "inbox" :query "tag:inbox" :key "i")
	     (:name "unread" :query "tag:unread" :key "u")
	     (:name "flagged" :query "tag:flagged" :key "f")
	     (:name "drafts" :query "tag:draft" :key "d")
	     (:name "today's mail" :query "date:today tag:inbox tag:unread" :key ".")
	     (:name "Todo" :query "tag:todo" :key "t")
	     (:name "This Week" :query "date:mon..today tag:inbox" :key "w")
	     (:name "Pull requests" :query "tag:pullrequest not tag:deleted" :key "p")
	     (:name "Sent" :query "is:sent" :key "s")))
   #+end_src

**** Sorting

   #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
     (setq notmuch-search-oldest-first nil)
   #+end_src
*** Bindings
Evilified bindings to notmuch

**** Search mode
#+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
  (defun notmuch-search-delete-threads (&optional beg end)
    (interactive (notmuch-interactive-region))
    (notmuch-search-tag '("+deleted" "-inbox") beg end)
    (notmuch-search-next-thread))

  ;; TODO: this function could be made more generic by checking
  ;; to see which notmuch mode we are in and calling the relevant
  ;; `notmuch-*-tag' function. e.g. `notmuch-search-tag', `notmuch-show-tag', etc.
  (defun notmuch-search-add-todo-tag (&optional beg end)
    (interactive (notmuch-interactive-region))
    (notmuch-search-tag '("+todo") beg end)
    (notmuch-search-next-thread))
#+end_src
       
**** Show mode
#+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
  (defun notmuch-show-delete-thread ()
    (interactive)
    (notmuch-show-tag '("+deleted" "-inbox")))

  (defun notmuch-show-tag-todo ()
    (interactive)
    (notmuch-show-tag '("+todo")))
#+end_src
   
** Provide =my-email=
  #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
    (provide 'my-email)
  #+end_src
* Text
** Mixed pitch mode
    Variable pitch (or proportional) fonts are those fonts which have
    different widths on a per-character basis. These are typically
    better for prose.

    Fixed pitch fonts are those which have the same width for each
    character. This means code formatting is preserved relative to
    each line, and does not vary on which letters are typed. This
    tends to be preferred for code.

    Using variable pitch fonts in text-inheriting modes is nice, but
    results in things like org source blocks using the same variable
    pitch as your prose.

    Fortunately, the ~mixed-pitch~ package is aware of the different
    font requirements of such modes and will use both variable and
    fixed pitch fonts in the same buffer according to use.

    #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
      (straight-use-package 'mixed-pitch)
    #+end_src

** Fill column
   Auto-fill mode uses a fixed column number to inform when emacs will
   insert a newline.

   Lets set it to something reasonable.

   #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
     (set-fill-column 80)
   #+end_src
** Text-mode hook
  #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
    (defun my-text-mode-hook ()
      (auto-fill-mode 1)
      (flyspell-mode 1))

    (add-hook 'text-mode-hook #'my-text-mode-hook)
  #+end_src

** Functions
*** Cycle capitalize word
    #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
      (defun cycle-capitalization ()
      	"Cycle capitalization of previous word.

      Capitalization schemes are:
      	- Regular capitalization: ensure only the first letter is capitalized
      	- All caps: Capitalize all letters of the word
      	- No caps: No Letters of the word are capitalized"
      	(interactive)
      	(let ((state (capitalize-state)))
      	  (save-excursion
      	    (goto-char (beginning-of-thing 'word))
      	    (cond
      	     ((eq 'lower state)
      	      (capitalize-word 1))
      	     ((eq 'capital state)
      	      (upcase-word 1))
      	     ((eq 'all-caps state)
      	      (downcase-word 1))))))

      (defun capitalize-state ()
        "Return a symbol representing the capitalization state of the previous word.

      Returns one of: 'lower, 'capital, or 'all-caps under the following senarios:

      	'lower    The first character of the word is alpha and lowercase.
      	'capital  The first character of the word is alpha and uppercase (but not every character in the word is uppercase.)
      	'all-caps All letters of the word are alpha and uppercase."
        (interactive)
        (let* ((word (word-at-point t))
      	     (upper-first-char-p (char-uppercase-p (string-to-char word)))
      	     (all-upper-p (map-every-p (lambda (i val) (char-uppercase-p val)) word)))
      	(cond
      	 (all-upper-p 'all-caps)
      	 (upper-first-char-p 'capital)
      	 (t 'lower))))

      (define-key global-map [remap capitalize-word] #'cycle-capitalization)
    #+end_src
     

** Provide =my-text=
  #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
    (provide 'my-text)
  #+end_src
* Timers (tmr)
The famous Prot has created the tmr package which makes setting timers
very easy.

#+begin_src emacs-lisp :tangle "my-modules/my-timers.el" :mkdirp yes
  (straight-use-package 'tmr)
  (require 'tmr)
  (provide 'my-timers)
#+end_src
* Git
** Magit
  Magit is amazing
  
**** Install the package

  #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
    (straight-use-package
     '(magit :type git :host github :repo "magit/magit"))
  #+end_src

** Forge
    Forges are a term representing a centralized version control
    location, like github. Magit bundles support for viewing content
    from forges (like pull requests), when required.

    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (straight-use-package 'forge)
    #+end_src
    
** Git gutters
    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (straight-use-package 'diff-hl)
      (global-diff-hl-mode 1)
    #+end_src
** Provide =my-git=
   #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
     (provide 'my-git)
   #+end_src

* Help utilities
  This encompasses man pages, info pages, describe-* windows, etc.
** Helpful package
    #+begin_src emacs-lisp :tangle "my-modules/my-help.el" :mkdirp yes
      (straight-use-package 'helpful)
    #+end_src
** Provide =my-help=
   #+begin_src emacs-lisp :tangle "my-modules/my-help.el" :mkdirp yes
     (provide 'my-help)
   #+end_src
* Just mode
    Just is a command line tool that seeks to simplify [[man:make]]
** Use package

    #+begin_src emacs-lisp :tangle "my-modules/my-just.el" :mkdirp yes
      (straight-use-package 'just-mode)
    #+end_src

** Provide package
    #+begin_src emacs-lisp :tangle "my-modules/my-just.el" :mkdirp yes
      (provide 'my-just)
    #+end_src

* Avy
Avy is great. It seems like somehow, I have it already, maybe through
ace-window?

Avy advertises itself as a quick way to jump around the frame...and it
is, but it has an incredible dispatch system that allows you to
connect the filter and selection process to one of any number of
actions.

Tying this up to embark is a natural extension of avy's action
dispatch system.

#+begin_src emacs-lisp :tangle "my-modules/my-avy.el" :mkdirp yes
  (defun avy-action-embark (pt)
    (unwind-protect
  	  (save-excursion
  		(goto-char pt)
  		(embark-act))
  	(select-window
  	 (cdr (ring-ref avy-ring 0))))
    t)

  (with-eval-after-load 'avy
    (setf (alist-get ?. avy-dispatch-alist) #'avy-action-embark))

  (provide 'my-avy)
#+end_src

* Registers

#+begin_src emacs-lisp :tangle "my-modules/my-registers.el" :mkdirp yes
  (setq register-use-preview 'insist)
  (provide 'my-registers)
#+end_src
