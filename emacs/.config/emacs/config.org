#+TITLE: Literate Emacs Config
#+AUTHOR: Jon Harder
#+STARTUP: show2levels
* Early init optimizations
** Disable built-in package.el
  #+begin_src emacs-lisp :tangle "early-init.el"
    ;; disable package.el in favor of straight.el
    (setq package-enable-at-startup nil)
  #+end_src

  #+RESULTS:

** Startup performance enhancements
   The aim here is to effectively disable the garbage collector during startup
   as emacs is not interactible during startup anyway. In the startup-hook we
   restore these settings to sensible values for runtime.

   #+begin_src emacs-lisp :tangle early-init.el
     (setq gc-cons-threshold most-positive-fixnum
	   gc-cons-percentage 0.5)
   #+end_src

** Performance monitoring
  It's helpful to track how long Emacs takes to load up. This normally
  isn't the most critical metric to track as I usually run emacs with
  ~emacs --daemon~, and open new emacs windows with ~emacsclient~, but
  helpful nonetheless.

  #+begin_src emacs-lisp :tangle "early-init.el"
    (add-hook 'emacs-startup-hook
	      (lambda ()
		(setq gc-cons-threshold (* 1024 1024 20)
		      gc-cons-percentage 0.2)
		(message "*** Emacs loaded in %s with %d garbage collections."
			 (format "%.2f seconds"
				 (float-time
				  (time-subtract after-init-time before-init-time)))
			 gcs-done)))
  #+end_src

* Package management
** Set up straight.el (package management)

   #+begin_src emacs-lisp :tangle "init.el"
   (setq straight-repository-branch "develop")
   
   (defvar bootstrap-version)
   (let ((bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-verision 6))
     (unless (file-exists-p bootstrap-file)
       (with-current-buffer
   	(url-retrieve-synchronously
   	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
   	 'silent 'inhibit-cookies)
         (goto-char (point-max))
         (eval-print-last-sexp)))
     (load bootstrap-file nil 'nomessage))
   #+end_src
** Local lisp loading
*** Load local-config
    There are some configuration settings that are local to the particular
    machine I'm running emacs on. These settings are stored in the file,
    =local-config.el=.

    This gets loaded first so that any later configuration can utilize it.

    #+begin_src emacs-lisp :tangle "init.el"
      (load-file (expand-file-name "local-config.el" user-emacs-directory))
    #+end_src
*** Adding my-modules to the load path
    #+begin_src emacs-lisp :tangle "init.el"
    (add-to-list 'load-path (locate-user-emacs-file "my-modules"))
    #+end_src

** Require all my modules
    #+begin_src emacs-lisp :tangle "init.el"
      (require 'my-appearance)
      (require 'my-modeline)
      (require 'my-core)
      (require 'my-evil-config)
      (require 'my-bindings)

      (require 'my-calendar)
      (require 'my-completion)
      (require 'my-tree-sitter)
      (require 'my-denote)
      (require 'my-dired)
      (require 'my-docker-mode)
      (require 'my-ediff)
      (require 'my-email)
      (require 'my-epub)
      (require 'my-gpg)
      (require 'my-help)
      (require 'my-http)
      (require 'my-ibuffer)
      (require 'my-icons)
      (require 'my-lisp-mode)
      (require 'my-git)
      (require 'my-markup)
      (require 'my-navigation)
      (require 'my-nushell-mode)
      (require 'my-org)
      (require 'my-php-mode)
      (require 'my-prog-mode)
      (require 'my-python-mode)
      (require 'my-rest-mode)
      (require 'my-spotify)
      (require 'my-text)

      (require 'my-rust-mode)
      (require 'my-search)
      (require 'my-shells)
      (require 'my-typst)
      (require 'my-terraform-mode)
      (require 'my-util)
      (require 'my-vim-mode)
      (require 'my-xref)
    #+end_src

* Appearance
** Color theme
   The modus theme set is the most complete and polished emacs color theme I've
   encountered. It's also WCAG 2 compliant meaning it will always have high color
   contrast between UI elements, making it one of the easiest themes on the eyes
   in any lighting situation.

   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (straight-use-package my-theme-package)
   #+end_src

*** Settings
**** Basic theme configuration
      #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
	(set-face-attribute 'bold nil :weight 'ultra-bold)
	(when t
	  (custom-set-faces
	   '(org-level-1 ((t (:height 1.6 :inherit outline-1))))
	   '(org-level-2 ((t (:height 1.5 :inherit outline-2))))
	   '(org-level-3 ((t (:height 1.2 :inherit outline-3))))
	   '(org-level-4 ((t (:height 1.1 :inherit outline-4))))
	   '(org-level-5 ((t (:height 1.0 :inherit outline-5))))
	   '(org-document-title ((t (:height 2.0 :underline t))))))
      #+end_src
**** Modus themes settings
     #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
      (progn ;; Modus configuration
	(require-theme 'modus-themes)
	(setq modus-themes-completions
	      '((matches . (extrabold underline))
		(selection . (semibold italic))))
	(setq modus-themes-prompts '(bold))
	(setq modus-themes-bold-constructs t)
	(setq modus-themes-common-palette-overrides
	      modus-themes-preset-overrides-intense)
	(setq modus-themes-variable-pitch-ui nil)
	(setq modus-themes-italic-constructs t)
	(setq modus-themes-org-blocks 'gray-background)
	(setq modus-themes-headings
	      '((1 . (variable-pitch 1.5))
		(2 . (1.3))
		(agenda-date . (1.3))
		(agenda-structure . (variable-pitch light 1.8))
		(t . (1.1)))))
    #+end_src
**** Ef-themes settings
    #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
      (straight-use-package 'ef-themes)
      ;; (setq ef-themes-headings ; read the manual's entry or the doc string
      ;;       '((0 variable-pitch bold 1.9)
      ;; 	(1 variable-pitch bold 1.8)
      ;; 	(2 variable-pitch regular 1.7)
      ;; 	(3 variable-pitch regular 1.6)
      ;; 	(4 variable-pitch light 1.5)
      ;; 	(5 variable-pitch light 1.4) ; absence of weight means `bold'
      ;; 	(6 variable-pitch light 1.3)
      ;; 	(7 variable-pitch light 1.2)
      ;; 	(t variable-pitch light 1.1)
      ;; 	(agenda-date . (1.3))
      ;; 	(agenda-structure . (variable pitch light 1.8))))
    #+end_src

**** Doom themes settings
     #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
       (straight-use-package 'doom-themes)
       (setq doom-rouge-brighter-comments t
	     doom-themes-enable-bold t
	     doom-themes-enable-italic t)
     #+end_src
*** Load theme
    #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
      (load-theme my-theme t)
   #+end_src

** Tweak display of UI elements
*** Menu bar mode

   The menu bar is the list of contextual dropdown options in the top of the
   application (or in the universal top bar on macs).

   I'm all for getting rid of UI clutter, especially if it's unused, but there
   are a lot of features in emacs... Having contextual help aids discoverability,
   and so it stays on.
   
   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (menu-bar-mode 1)
   #+end_src
   
*** Scroll bar mode
   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (scroll-bar-mode -1)
   #+end_src
*** Tool bar mode
   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (tool-bar-mode -1)
   #+end_src

** Frame settings
   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (setq frame-resize-pixelwise t
	   frame-inhibit-implied-resize t
	   inhibit-splash-screen t
	   inhibit-startup-screen t)
   #+end_src
** Bells are evil
   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (setq ring-bell-function 'ignore)
   #+end_src
** Time display
*** Format
    I like 24 hour time; one time being ambiguous is unnecessarily cumbersome.

   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
      (setq display-time-24hr-format t)
    #+end_src

*** Add the time to the mode line

   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (display-time)
   #+end_src

** Font

   I use FiraCode patched with the Nerd icons

   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (let ((size 175))
       (set-face-attribute 'default nil :font my-font :height size)
       (set-frame-font my-font nil t)
       (add-to-list 'default-frame-alist
		    `(font . ,my-font)))
   #+end_src

** Tabs
   Tabs are a useful workspace organization concept. You can have discrete window/buffer arrangements per tab,
   allowing you to switch between them at will. They are pretty flexible so you could use them for keeping
   track of different projects. Or you could have different window configuations for the same set of buffers
   on different tabs to help with different types of work within the same project.

   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (setq tab-bar-show 1)
   #+end_src
** Spacious Padding
   #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
     (straight-use-package 'spacious-padding)
   #+end_src

** provide the module
  #+begin_src emacs-lisp :tangle "my-modules/my-appearance.el" :mkdirp yes
    (provide 'my-appearance)
  #+end_src
* mode line
** Faces for the modeline
   #+begin_src emacs-lisp :tangle "my-modules/my-modeline.el" :mkdirp yes
     ;; TODO: update faces to make this prettier
     ;; how do you work off of the color palette of the current theme?
     (defface my-modeline-mode-face
       '((t :background "grey50" :foreground "white" :inherit bold))
       "Face for the major mode when displayed in the modeline.")

     (defface my-modeline-buffer-face
       '((t :inherit bold))
       "Face for displaying the buffer name on the modeline.")
     (defface my-modeline-evil-replace-state
       '((t :background "red"))
       "Face to indicate the current evil state is replace.")
     (defface my-modeline-evil-emacs-state
       '((t :background "purple"))
       "Face to indicate the current evil state is Emacs.")

     (defface my-modeline-indicator-blue
       '((default :inherit bold)
	 (((class color) (min-colors 88) (background light))
	  :foreground "#00228a")
	 (((class color) (min-colors 88) (background dark))
	  :foreground "#880bfff")
	 (t :foreground "blue"))
       "Face for modeline indicators")

     (defface my-modeline-indicator-green
       '((default :inherit bold)
	 (((class color) (min-colors 88) (background light))
	  :foreground "#005f00")
	 (((class color) (min-colors 88) (background dark))
	  :foreground "#73fa7f")
	 (t :foreground "green"))
       "Face for modeline indicators")

     (defface my-modeline-indicator-red
       '((default :inherit bold)
	 (((class color) (min-colors 88) (background light))
	  :foreground "#880000")
	 (((class color) (min-colors 88) (background dark))
	  :foreground "#ff9f9f")
	 (t :foreground "red"))
       "Face for modeline indicators")

     (defface my-modeline-indicator-red-bg
       '((default :inherit bold)
	 (((class color) (min-colors 88))
	  :foreground "white" :background "red"))
       "Face for modeline indicators")

     (defface my-modeline-indicator-magenta
       '((default :inherit bold)
	 (((class color) (min-colors 88) (background light))
	  :foreground "#6a1aaf")
	 (((class color) (min-colors 88) (background dark))
	  :foreground "#e0a0ff")
	 (t :foreground "magenta"))
       "Face for modeline indicators")

     (defface my-modeline-indicator-yellow
       '((default :inherit bold)
	 (((class color) (min-colors 88) (background light))
	  :foreground "#6f4000")
	 (((class color) (min-colors 88) (background dark))
	  :foreground "#f0c526")
	 (t :foreground "yellow"))
       "Face for modeline indicators")
   #+end_src

** Helper functions to return strings for display in the modeline 
    #+begin_src emacs-lisp :tangle "my-modules/my-modeline.el" :mkdirp yes
      (defun my-modeline--major-mode-name ()
	"Return the capitalized `major-mode' name."
	(capitalize (string-replace "-mode" "" (symbol-name major-mode))))

      (defun my-modeline--evil-state-name-and-face ()
	"Return a symbol associated with a face to propertize the current evil state."
	(pcase evil-state
	  ('insert '("<I>" my-modeline-indicator-magenta))
	  ('normal '("<N>" my-modeline-indicator-green))
	  ('visual '("<V>" my-modeline-indicator-yellow))
	  ('replace '("<R>" my-modeline-indicator-red))
	  ('emacs '("<E>" my-modeline-evil-emacs-state))))

      (defun my-modeline--buffer-name ()
	"Return the buffer's name."
	(format " %s "(buffer-name)))

      (defun my-modeline--buffer-name-face ()
	(let ((file (buffer-name)))
	  (cond
	   ((and (mode-line-window-selected-p)
		 file
		 (buffer-modified-p))
	    '(italic underline mode-line-buffer-id))
	   ((and file (buffer-modified-p))
	    'italic)
	   ((mode-line-window-selected-p)
	    '(underline mode-line-buffer-id)))))

      (defun my-modeline--major-mode-indicator ()
	(let ((indicator (cond
			  ((derived-mode-p 'text-mode) "ยง")
			  ((derived-mode-p 'prog-mode) "ฮป")
			  ((or (derived-mode-p 'comint-mode)
			       (derived-mode-p 'eshell-mode))
			   ">_"))))
	  (propertize indicator 'face 'shadow)))

      (defun my-modeline--git-branch ()
	"Return propertized git branch."
	(when-let ((branch (car (vc-git-branches))))
	  (propertize branch 'face 'bold)))
    #+end_src

** Local variables which make up the segments of my modeline
    #+begin_src emacs-lisp :tangle "my-modules/my-modeline.el" :mkdirp yes
      (defvar-local my-modeline-remote
	  '(:eval
	    (when (file-remote-p default-directory)
	      (propertize " @ " 'face 'my-modeline-indicator-red-bg))))


      (defvar-local my-modeline-git-branch
	  '(:eval
	    (if-let (((mode-line-window-selected-p))
		     (branch (my-modeline--git-branch)))
		(list
		 " "
		 (propertize (char-to-string #xE0A0) 'face 'shadow)
		 " "
		 branch
		 " "))))

      (defvar-local my-modeline-evil-state
	  '(:eval
	    (let* ((name-face (my-modeline--evil-state-name-and-face))
		   (name (car name-face))
		   (face (cadr name-face)))
	      (propertize (upcase name) 'face face))))

      (defvar-local my-modeline-major-mode
	  '(:eval
	    (when (mode-line-window-selected-p)
	      (list
	       (my-modeline--major-mode-indicator)
	       " "
	       (propertize (my-modeline--major-mode-name)
			   'face 'my-modeline-buffer-face)))))

      (defvar-local my-modeline-buffer-name
	  '(:eval
	    (list
	     (format "%s" (propertize
			   (my-modeline--buffer-name)
			   'face (my-modeline--buffer-name-face)))
	     " ")))

      (defvar-local my-modeline-date
	  '(:eval
	    (when (mode-line-window-selected-p)
	      (let ((date-time (format-time-string "%H:%M %b %d, %Y")))
		(propertize date-time 'face 'underline)))))

      (defvar-local my-modeline-pos-in-buffer
	  '(:eval
	    (when (mode-line-window-selected-p)
	      (let ((pos (line-number-at-pos)))
		(list
		 (propertize "L" 'face 'bold)
		 (format "%s" pos)
		 " "
		 )))))

      ;; Any variable used in the mode line format MUST be marked as `risky-local-variable'.
      (dolist (component '(my-modeline-git-branch
			   my-modeline-major-mode
			   my-modeline-buffer-name
			   my-modeline-remote
			   my-modeline-evil-state
			   my-modeline-pos-in-buffer
			   my-modeline-date))
	(put component 'risky-local-variable t))
    #+end_src

** The mode line format
     #+begin_src emacs-lisp :tangle "my-modules/my-modeline.el" :mkdirp yes
       ;;; My mode line
       (setq mode-line-right-align-edge 'right-margin)
       (setq-default mode-line-format
		     '("%e"
		       my-modeline-evil-state
		       my-modeline-remote
		       my-modeline-buffer-name
		       my-modeline-major-mode
		       " "
		       my-modeline-git-branch
		       " "
                       my-modeline-pos-in-buffer
		       my-modeline-date))

       ;;; The default mode line
       ;; (setq-default mode-line-format
       ;; 		     '("%e" mode-line-front-space
       ;; 		       (:propertize
       ;; 			("" mode-line-mule-info mode-line-client mode-line-modified
       ;; 			 mode-line-remote)
       ;; 			display (min-width (5.0)))
       ;; 		       mode-line-frame-identification mode-line-buffer-identification "   "
       ;; 		       mode-line-position evil-mode-line-tag (vc-mode vc-mode) "  " mode-line-modes
       ;; 		       mode-line-misc-info mode-line-end-spaces))
     #+end_src
** Provide =my-modeline=
    #+begin_src emacs-lisp :tangle "my-modules/my-modeline.el" :mkdirp yes
      (provide 'my-modeline)
    #+end_src

* Base settings
** Customization file

  Here's just a holding ground for general emacs settings that
  don't seem to fit in any more specific location.

  When emacs makes customizations on my behalf, it throws the
  resultant elist code into my init file. It's great that it
  produces visible, editable, version controllable config, but
  I don't like it in my init file. Let's move it somewhere else.

  #+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
    (setq custom-file (concat user-emacs-directory "custom.el"))
  #+end_src

** Backups

  Emacs helpfully creates local backups of any files you're editing so that
  if something happens to your session before saving the file, you'll have
  a backup of the local changes.

  It *un*-helpfully defaults to placing them in the same directory as the file
  you are editing. This clutters things up immensely, particularily when you
  are working in a version-controlled project and have to tell your VC tool
  to ignore them.

  Much better to just place them in a dedicated directory and forget about them.
  Emacs will still save the day if something happens, but you don't have to
  worry about it.

  #+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
    (setq backup-directory-alist '(("." . "~/.backups")))
  #+end_src

** Dictionary

   Emacs has built in dictionary support (because of course it does). By dafault, it
   expects you to be running a dictionary server ~dictd~ locally. If it can't be found,
   it falls back to [[dict.org]]. I'm fine with going over the wire for my definitions,
   so let's just set it as default.

   #+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
     (setq dictionary-server "dict.org")
   #+end_src

** Provide the module

   #+begin_src emacs-lisp :tangle "my-modules/my-core.el" :mkdirp yes
     (provide 'my-core)
   #+end_src

* Evil (vim)

  Evil mode is the backbone of this configuration. Coming from years
  of vim use, modal editing is burned into my brain stem.

  Fortunately, emacs has some of the best vim emulation of any editor
  or environment around in the way of ~evil-mode~.

** Install the package and enable it

  #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
    (straight-use-package 'evil)
    (setq evil-vsplit-window-right t)
    (setq evil-split-window-below t)
    (setq evil-undo-system 'undo-redo)
    (evil-mode 1)
  #+end_src

** Starting state for major modes

   Sometimes I want to have some evil state other than =normal= for a particular
   major mode, or the mode might not start in =normal= mode for some reason.
   Regardless, configure thes modes with the desired initial state.

*** Normal modes
   #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
     (defvar my-normal-modes
       '(Info-mode
	 Man-mode
	 magit-log-mode
	 occur-mode
	 magit-revision-mode
	 git-rebase-mode
	 notmuch-hello-mode
	 notmuch-search-mode
	 notmuch-show-mode
	 ibuffer-mode
	 calendar-mode
	 org-agenda-mode
	 grep-mode)
       "Modes for which evil should begin in normal mode.")

     (dolist (mode my-normal-modes)
       (evil-set-initial-state mode 'normal))
  #+end_src

*** Insert modes
   #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
     (defvar my-insert-modes
       '(vterm-mode
	 eshell-mode
	 eat-mode)
       "Modes for which evil should begin in insert mode.")

     (dolist (mode my-insert-modes)
       (evil-set-initial-state mode 'insert))
  #+end_src

*** Emacs modes
  #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
     (defvar my-emacs-modes '()
       "Modes to start in native emacs mode.")

     (dolist (mode my-emacs-modes)
       (evil-set-initial-state mode 'emacs))
   #+end_src

** Cursor shape/color

   It's helpful to set the cursor to different colors and shapes to help remind
   me what evil state I'm currently in.

   /NOTE:/ is there a way to set these colors to something theme compatible?

   #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
     (setq evil-normal-state-cursor '(box "light blue")
	   evil-insert-state-cursor '(bar "medium sea green")
	   evil-visual-state-cursor '(hollow "orange"))
   #+end_src

** Leader key

  The leader key is a super handy global prefix for keybindings.
  It's used in this configuration as the entrypoint for most bindings.

  After entering the leader key =SPC=, bindings are further subdivided
  by the logical operations or object those bindings act on.

  | _binding_ | _action_                           |
  |---------+----------------------------------|
  | SPC a   | application launcher             |
  | SPC b   | buffer actions                   |
  | SPC c   | config actions                   |
  | SPC d   | dired actions                    |
  | SPC e   | evaluation actions               |
  | SPC f   | file based actions               |
  | SPC g   | magit                            |
  | SPC h   | help actions                     |
  | SPC m   | [reserved] mode specific actions |
  | SPC o   | org actions                      |
  | SPC t   | tab actions                      |
  | SPC w   | window based actions             |

  #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
    (evil-set-leader 'normal (kbd "<SPC>"))
  #+end_src

** Evil surround
  #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
    (straight-use-package 'evil-surround)
    (global-evil-surround-mode 1)
  #+end_src

** Evil numbers

   For some reason, vim's increment and decrement number functionality
   is not replicated by evil. This package just re-introduces that
   behavior

   #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
     (straight-use-package 'evil-numbers)
     (define-key evil-normal-state-map (kbd "C-a") #'evil-numbers/inc-at-pt)
     (define-key evil-normal-state-map (kbd "C-x") #'evil-numbers/dec-at-pt)
   #+end_src

** Evil comments
  #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
    (straight-use-package 'evil-commentary)
    (evil-commentary-mode)
    (evil-define-key '(insert normal visual) evil-commentary-mode-map (kbd "s-;") #'evil-commentary-line)
  #+end_src
** Provide the module
  
   #+begin_src emacs-lisp :tangle "my-modules/my-evil-config.el" :mkdirp yes
     (provide 'my-evil-config)
   #+end_src

* Calendar
** Base settings

   Set the date style to iso (day month year).

   #+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp yes
     (setq calendar-date-style 'iso)
   #+end_src
** Bindings
   #+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp
     (evil-define-key 'normal calendar-mode-map
       (kbd "l") 'calendar-forward-day
       (kbd "h") 'calendar-backward-day
       (kbd "w") #'calendar-forward-week
       (kbd "b") #'calendar-backward-week
       (kbd "k") 'calendar-backward-week
       (kbd "j") 'calendar-forward-week
       (kbd "q") 'calendar-exit
       (kbd "0") 'calendar-beginning-of-week
       (kbd "$") 'calendar-end-of-week
       (kbd ".") 'calendar-goto-today
       (kbd "d d") 'diary-view-entries
       (kbd "d i") 'diary-insert-entry)
   #+end_src
** Diary

   The diary is (for me) mostly a way to jot down an appointment or reminder.

  #+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp yes
     (appt-activate 1)

     (evil-define-key 'normal diary-fancy-display-mode-map
       (kbd "q") 'quit-window)
   #+end_src

** Provide the module

  #+begin_src emacs-lisp :tangle "my-modules/my-calendar.el" :mkdirp yes
    (provide 'my-calendar)
  #+end_src
* Completion

** General minibuffer settings

   When interacting with the [[elisp:(info "(emacs) Minibuffer")][minibuffer]], you may want to execute a command
   that itself occupies the minibuffer. Enabling recursive-minibuffers allows
   for you to nest arbitrarily deep minibuffer commands.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (setq enable-recursive-minibuffers t)
   #+end_src

   When you've used a command once, you will probably use it again in the near
   future. savehist is a simple package that remembers and promotes recent
   commands to the top of the prompted list of completions.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (straight-use-package 'savehist)
     (savehist-mode)
   #+end_src

   Do not allow the cursor in the minibuffer

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (setq minibuffer-prompt-properties
	   '(read-only t cursor-intangible t face minibuffer-prompt))
     (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
   #+end_src
   
** Vertico

   Vertico is a minibuffer completion enhancement library which wraps emacs'
   built in [[elisp:(info "(emacs) Completion")][completion]] functionality. It is a member of a new era of packages
   which seek to enhance existing methods in emacs, rather than replace them
   entirely (looking at you helm).

   Vertico specifically seeks to enhance `completing-read', a generic method
   that prompts users to select from one of a provided set of alternatives.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (straight-use-package 'vertico)
     (vertico-mode 1)
     (define-key vertico-map (kbd "<escape>") #'keyboard-escape-quit)
   #+end_src

   Vertico also has a small stable of add-ons which change the default
   UI or behavior of vertico. Here vertico-directory is enabled, which
   introduces commands to delete directories fragments of the prompted
   file-path.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (require 'vertico-directory)
     (define-key vertico-map (kbd "DEL") #'vertico-directory-delete-char)
     (define-key vertico-map (kbd "RET") #'vertico-directory-enter)
   #+end_src

   Wipe the shadowed input in minibuffer when the current input superscedes
   it, e.g. =~/some/path/~/base= should erase =~/some/path= since =~/base= shadows
   it.

   #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
   #+end_src

** Corfu

  Corfu offers completion in buffer, replacing company mode which sidesteps
  Emacs' built in completion mechanisms.

  #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
    (straight-use-package 'corfu)
    (setq corfu-auto t
	  corfu-separator ?\s
	  tab-always-indent 'complete)
    (global-corfu-mode 1)
  #+end_src

** Marginalia

   Marginalia is a small package that adds contextual information "in the margins"
   of the completion. It is a perfect compliment to the work of vertico (or
   other completion frameworks, it doesn't care)

   This means file prompts will contain file permissions, last modified time,
   file size. Commands will display their doc string, etc.

  #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (straight-use-package 'marginalia)
     (marginalia-mode 1)
   #+end_src

** Orderless

   The orderless package allows for fuzzy searching of terms sepparated by spaces
   (by default) and finds results regardless of search term order, thus, orderless.

  #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
     (straight-use-package 'orderless)
     (setq completion-styles '(orderless basic)
	   completion-category-defaults nil
	   completion-category-overrides '((file (styles partial-completion))))
   #+end_src
   
** Consult

  #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
    (straight-use-package 'consult)
  #+end_src

** Embark

    It's kinda like right click, for your keyboard.
    Activating embark gives you a context-aware menu
    of actions to perform on the target under point.

    #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
      (straight-use-package 'embark)
      (straight-use-package 'embark-consult)
      (setq prefix-help-command #'embark-prefix-help-command)
      (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
      (evil-define-key '(normal motion visual insert emacs) 'global
	(kbd "s-<return>") #'embark-dwim
	(kbd "C-<return>") #'embark-act)
      (define-key minibuffer-local-map
	(kbd "C-<return>") #'embark-act)
    #+end_src
   
** Provide the module
    #+begin_src emacs-lisp :tangle "my-modules/my-completion.el" :mkdirp yes
      (provide 'my-completion)
    #+end_src
 
* Icons
** Set up all the icons
  #+begin_src emacs-lisp :tangle "my-modules/my-icons.el" :mkdirp yes
    ;; Icons
    (straight-use-package 'all-the-icons)
    ;;; If icons aren't showing up, you may need to install the font.
    ;;; If so, uncomment and execute the following line.
    ;; (all-the-icons-install-fonts t)
#+end_src

** And completion support for all the icons

#+begin_src emacs-lisp :tangle "my-modules/my-icons.el" :mkdirp yes
    (straight-use-package 'all-the-icons-completion)
    (all-the-icons-completion-mode)
    (if (require 'marginalia nil nil)
	(add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))
#+end_src

** Provide the module

#+begin_src emacs-lisp :tangle "my-modules/my-icons.el" :mkdirp yes
    (provide 'my-icons)
  #+end_src 

* Ediff
** Window management
   Ediff puts its control panal in a separate frame, which makes tiling window managers
   quite unhappy. Let's configure it to use the /plain/ setup which just makes a small
   window at the bottom of the current frame.
   
  #+begin_src emacs-lisp :tangle "my-modules/my-ediff.el" :mkdirp yes
    (require 'ediff)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (setq ediff-split-window-function 'split-window-horizontally)
  #+end_src

** Bindings
  #+begin_src emacs-lisp :tangle "my-modules/my-ediff.el" :mkdirp yes
    (evil-define-key 'normal ediff-mode-map
      (kbd "j") #'ediff-next-difference
      (kbd "k") #'ediff-previous-difference)
  #+end_src

** Provide =my-ediff=
  #+begin_src emacs-lisp :tangle "my-modules/my-ediff.el" :mkdirp yes
    (provide 'my-ediff)
  #+end_src
  
* Spotify
#+begin_src emacs-lisp :tangle "my-modules/my-spotify.el" :mkdirp yes
  (straight-use-package 'smudge)

  (defun load-spotify-credentials ()
    (interactive)
    (load "~/spotify.el.gpg"))

  (evil-define-key 'normal smudge-track-search-mode-map
    (kbd "RET") #'smudge-track-select)

  (provide 'my-spotify)
#+end_src
* Denote
** Basic settings
  #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
    (straight-use-package 'denote)

    (denote-rename-buffer-mode 1)
    (setq denote-known-keywords '("emacs" "work" "article" "notes" "blog"))

    (setq denote-directory my-notes-directory)

    (setq denote-dired-directories
	  (list (expand-file-name denote-directory)))
    (setq denote-prompts '(title subdirectory keywords))
  #+end_src

** Helper functions
  #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
    (defun denote-search-content ()
      (interactive)
      (consult-ripgrep denote-directory))

    (defun denote-dired ()
      (interactive)
      (dired denote-directory))
  #+end_src
   
** Bindings

   #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
     (evil-define-key 'normal 'global
       (kbd "<leader> n /") #'denote-search-content
       (kbd "<leader> n J") #'denote-journal-extras-new-entry
       (kbd "<leader> n b") #'denote-backlinks
       (kbd "<leader> n d") #'denote-dired
       (kbd "<leader> n f") #'denote-open-or-create
       (kbd "<leader> n j") #'denote-journal-extras-new-or-existing-entry
       (kbd "<leader> n l") #'denote-link
       (kbd "<leader> n n") #'denote
       (kbd "<leader> n r") #'denote-rename-file
       (kbd "<leader> n s") #'denote-signature)
   #+end_src

   And for the specialized ~backlinks-mode~ to display all links to the current
   denote buffer.

   #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
     (evil-define-key 'normal denote-backlinks-mode-map
       (kbd "j") #'denote-backlinks-next
       (kbd "k") #'denote-backlinks-prev)
   #+end_src

** Journaling
   #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
     (require 'denote-journal-extras)
     (setq denote-journal-extras-directory (concat denote-directory "/journal"))
     (add-to-list 'denote-dired-directories denote-journal-extras-directory)
   #+end_src

** Silos
   Silos are a way to fully sepparate notes from each other. In order
   to fully support them, we'll need to tell denote where each silo
   lives.

   #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
     (require 'denote-silo-extras)
     (let ((my-silo-dirs (list
			  (expand-file-name
			   "~/Dropbox/Personal")
			  (expand-file-name
			   "~/Dropbox/RBC/Internship"))))
       (dolist (dir my-silo-dirs)
	 (add-to-list 'denote-silo-extras-directories dir)
	 (add-to-list 'denote-dired-directories dir)))
   #+end_src

** Hooks
   #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
    (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
   #+end_src

** Provide the module
   #+begin_src emacs-lisp :tangle "my-modules/my-denote.el" :mkdirp yes
    (provide 'my-denote)
   #+end_src

* Dired

  The Dir(ectory) Ed(itor). [[elisp:(info "(emacs) Dired")][Dired]] is a text based file manager, baked into
  emacs. It uses the modest [[man:ls][ls]] command to generate the directory listing,
  and adds a ton of functionality on top, allowing for inteligent commands
  to operate on the seleted file(s). This only scratches the surface of
  what it can do, so seriously, read the info doc.

** Settings

   #+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
     (setq dired-kill-when-opening-new-dired-buffer t) 
     (require 'dired)
     (setq dired-listing-switches "-hAl")
     ;; this pre-fills the destination prompt of copy and rename
     ;; commands with the directory of the other dired buffer
     ;; if one is open. Very handy
     (setq dired-dwim-target t)

     ;; don't show all the file details by default
     ;; They're still accessible with '('
     (add-hook 'dired-mode-hook 'dired-hide-details-mode)
   #+end_src

   I want to be able to toggle the display of dotfiles in dired. This function allows me to
   do exactly that.

   #+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
     (defun dired-dotfiles-toggle ()
       (interactive)
       (when (equal major-mode 'dired-mode)
	 (if (or (not (boundp 'dired-dotfiles-show-p)) dired-dotfiles-show-p)
	     (progn
	       (set (make-local-variable 'dired-dotfiles-show-p) nil)
	       (message "h")
	       (dired-mark-files-regexp "^\\\.")
	       (dired-do-kill-lines))
	   (progn (revert-buffer)
		  (set (make-local-variable 'dired-dotfiles-show-p) t)))))

     (defun dired-mark-files-extension (extension)
       "Mark all files with the given file EXTENSION.

     EXTENSION should not contain the . prefix.
     When called interactively, derive the extension from the current file
     under the point in the dired buffer."
       (interactive
	(list (if current-prefix-arg
		  (read-string "Extension: ")
		(file-name-extension (dired-get-filename))))
	'dired-mode)
       (dired-mark-files-regexp (concat "." extension "$")))
   #+end_src
** Bindings

    #+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
      (define-key dired-mode-map (kbd "SPC") nil)
      (evil-define-key '(normal motion) dired-mode-map
	(kbd "j") #'dired-next-line
	(kbd "k") #'dired-previous-line
	(kbd "h") #'dired-up-directory
	(kbd "l") #'dired-find-file
	(kbd "n") #'evil-search-next
	(kbd "e") #'dired-mark-files-extension
        (kbd "r") #'revert-buffer
	(kbd "N") #'evil-search-previous
	(kbd "s") #'eshell
	(kbd "g o") #'dired-insert-subdir
	(kbd "g d") #'dired-kill-subdir
	(kbd "g j") #'dired-next-subdir
	(kbd "g k") #'dired-prev-subdir
	(kbd ".") #'dired-dotfiles-toggle
	(kbd "g g") #'dired-first-file
	(kbd "G") #'dired-last-file
	(kbd "<left>") #'dired-up-directory
	(kbd "<right>") #'dired-find-file
	(kbd "<up>") #'dired-previous-line
	(kbd "<down>") #'dired-next-line)
    #+end_src
** Helper functions
  
   #+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
     (defun dired-first-file ()
       "Jump the point to the first dired entry that isn't . or .."
       (interactive)
       (beginning-of-buffer)
       (dired-next-line 1))

     (defun dired-last-file ()
       "Jump the point to the last dired entry."
       (interactive)
       (end-of-buffer)
       (dired-next-line -1))

   #+end_src

** dired-preview

   sometimes it's handy to preview the file under point as you're navigating
   a directory. dired-preview allows for exactly this behavior.

   #+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
     (straight-use-package 'dired-preview)
     (setq dired-preview-delay 0.2)
     (evil-define-key 'normal dired-mode-map
       (kbd "P") #'dired-preview-global-mode)
   #+end_src

** Icons

  #+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
    (straight-use-package 'all-the-icons-dired)
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
    (setq all-the-icons-dired-monochrome nil)
  #+end_src

** Provide the module

  #+begin_src emacs-lisp :tangle "my-modules/my-dired.el" :mkdirp yes
    (provide 'my-dired)
  #+end_src
  
* GPG (egp)

  GPG allows you to easily encrypt/decrypt files with either symmetric
  (shared key) or asymetric (private key) encryption.

  Emacs hooks into this seemlessly by automatically decrypting encrypted
  files automatically when opening them using any loaded encyption keys
  you have on the system.

** Disable waiting for status

  There is an outstanding bug in epg where waiting for the enryption status
  will hang, which blocks the whole editor. We can disable this for now.

  #+begin_src emacs-lisp :tangle "my-modules/my-gpg.el" :mkdirp yes
    (fset 'epg-wait-for-status 'ignore)
  #+end_src

** PIN entry

  PIN entry is used to authorize a gpg key for use. By default emacs will
  reach out to an external proccess to prompt for the PIN. But this is
  emacs, let's make emacs do it.

  #+begin_src emacs-lisp :tangle "my-modules/my-gpg.el" :mkdirp yes
    (setq epg-pinentry-mode 'loopback)
  #+end_src

** Bindings
   #+begin_src emacs-lisp :tangle "my-modules/my-gpg.el" :mkdirp yes
     (evil-define-key 'normal epa-key-list-mode-map
       (kbd "TAB") #'forward-button
       (kbd "m") #'epa-mark-key
       (kbd "u") #'epa-unmark-key)
   #+end_src

** Provide the module
  
  #+begin_src emacs-lisp :tangle "my-modules/my-gpg.el" :mkdirp yes
    (provide 'my-gpg)
  #+end_src

* Http server (simple-httpd)
  This allows emacs to spin up a local http server to serve local
  files on the filesystem.

** Add the package
  #+begin_src emacs-lisp :tangle "my-modules/my-http.el" :mkdirp yes
    (straight-use-package 'simple-httpd)
  #+end_src

** Provide the module

  #+begin_src emacs-lisp :tangle "my-modules/my-http.el" :mkdirp yes
    (provide 'my-http)
  #+end_src

* Epub support
** Load nov mode and associate it with .epub files
   #+begin_src emacs-lisp :tangle "my-modules/my-epub.el" :mkdirp yes
     (straight-use-package 'nov)
     (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
   #+end_src

** Provide the module
   #+begin_src emacs-lisp :tangle "my-modules/my-epub.el" :mkdirp yes
     (provide 'my-epub)
   #+end_src

* Programming
** Prog mode
    Emacs has a general ~prog~ mode, serving as the base major mode for
    all language specific programming modes. Adding settings and hooks
    for this mode means they will be set for all programming languages.

*** Rainbow delimiters
   
    Highlight netsted delimeters with unique colors so you can tell
    at a glance how deep you are.


    #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
      (straight-use-package 'rainbow-delimiters)
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    #+end_src

*** Eglot

   Language server client implimentation. Comes baked into emacs starting
   at version 29.

   There seems to be a bug with the latest version of `menu-bar' (maybe?
   or perhaps in `project'?)

   Eglot attempts to insert itself info the menu bar, but the project
   entry in the menu bar is not defined. Setting this variable to ~nil~
   resolves the immediate issue causing ~eglot~ to crash. It is unknown
   what downstream ramifications this actually causes.

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (defvar menu-bar-project-menu '())
   #+end_src

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (add-hook 'eglot-managed-mode-hook
	       (lambda ()
		 (setq eldoc-documentation-strategy #'eldoc-documentation-compose)
		 (setq eldoc-documentation-functions
		       '(flymake-eldoc-function
			 eglot-signature-eldoc-function
			 eglot-hover-eldoc-function))))
   #+end_src

   And for support for languages that aren't pre-configured out of
   the box by eglot:

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (with-eval-after-load 'eglot
       (add-to-list 'eglot-server-programs
		    `(terraform-mode . ("terraform-ls" "serve"))))
   #+end_src

*** Highlight TODO statements

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (straight-use-package 'hl-todo)
     (global-hl-todo-mode 1)
   #+end_src
*** Electric pair mode
   This is a fairly simple mode that automatically inserts the matching symbol. =)= after typing =(=
   for instance.

   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (electric-pair-mode 1)
   #+end_src
*** Provide =my-prog-mode=
   #+begin_src emacs-lisp :tangle "my-modules/my-prog-mode.el" :mkdirp yes
     (provide 'my-prog-mode)
   #+end_src
    
** Tree Sitter
*** Overview
    Tree sitter allows for parsing structured text formats into an
    abstract syntax tree. From there, it provides language agnostic
    methods to find and modify the AST. Having the parse tree allows
    for far more consistent and robust syntax highlighting, but beyond
    that, it will allow for structured text editing which operates at
    the level of syntactical objects rather than characters.

*** Install the package
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (straight-use-package 'tree-sitter)
      (straight-use-package 'tree-sitter-langs)
    #+end_src

*** Install languages
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (setq treesit-language-source-alist
	    '((rust "https://github.com/tree-sitter/tree-sitter-rust")
	      (typst "https://github.com/uben0/tree-sitter-typst")))

      (setq treesit-load-name-override-list '((rust "libtree-sitter-rust" "tree_sitter_rust")))
    #+end_src

*** Enable global tree sitter mode
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (global-tree-sitter-mode)
      (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
    #+end_src

*** Provide the module
    #+begin_src emacs-lisp :tangle "my-modules/my-tree-sitter.el" :mkdirp yes
      (provide 'my-tree-sitter)
    #+end_src
** Rest mode
   Run http commands using simple http spec

   #+begin_src emacs-lisp :tangle "my-modules/my-rest-mode.el" :mkdirp yes
     (straight-use-package 'restclient)
     (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode))
     (provide 'my-rest-mode)
   #+end_src
 
** Dockerfile support
   #+begin_src emacs-lisp :tangle "my-modules/my-docker-mode.el" :mkdirp yes
     (straight-use-package 'dockerfile-mode)
     (provide 'my-docker-mode)
   #+end_src
** Lisp modes
*** Indentation
   #+begin_src emacs-lisp :tangle "my-modules/my-lisp-mode.el" :mkdirp yes
     (straight-use-package 'aggressive-indent)
     (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
     (provide 'my-lisp-mode)
   #+end_src
** Markup languages
*** Markdown
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'markdown-mode)
   #+end_src

*** Json
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'json-mode)
   #+end_src

*** Yaml 
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'yaml-mode)
   #+end_src
*** Json
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (straight-use-package 'json-mode)
   #+end_src
*** Provide =my-markup=
   #+begin_src emacs-lisp :tangle "my-modules/my-markup.el" :mkdirp yes
     (provide 'my-markup)
   #+end_src
** Terraform 
   #+begin_src emacs-lisp :tangle "my-modules/my-terraform-mode.el" :mkdirp yes
     (straight-use-package 'terraform-mode)
     (provide 'my-terraform-mode)
   #+end_src

** PHP

   Configure eglot to use inteliphense

   *This doesn't work currently. not sure what's wrong with intelephense*
   #+begin_src emacs-lisp :tangle "my-modules/my-php-mode.el" :mkdirp yes
     ;; (with-eval-after-load 'eglot
     ;;   (add-to-list 'eglot-server-programs
     ;;	    '(php-mode . ("intelephense" "--stdio"))))
     (straight-use-package 'php-mode)
     (provide 'my-php-mode)
   #+end_src

** Python
*** Pipfile support
    #+begin_src emacs-lisp :tangle "my-modules/my-python-mode.el" :mkdirp yes
      (add-to-list 'auto-mode-alist '("Pipfile" . conf-toml-mode))
    #+end_src
*** Provide =my-python-mode=
    #+begin_src emacs-lisp :tangle "my-modules/my-python-mode.el" :mkdirp yes
      (provide 'my-python-mode)
    #+end_src

** Rust
   #+begin_src emacs-lisp :tangle "my-modules/my-rust-mode.el" :mkdirp yes
     (straight-use-package 'rust-mode)
     (setq rust-format-on-save t)
     (add-hook 'rust-mode-hook
	       (lambda () (prettify-symbols-mode)))
     (provide 'my-rust-mode)
   #+end_src

** Vimrc

  This adds syntax highlighting for the random times I'll need to edit
  a vimrc-esque file from emacs.

  #+begin_src emacs-lisp :tangle "my-modules/my-vim-mode.el" :mkdirp yes
    (straight-use-package 'vimrc-mode)
    (provide 'my-vim-mode)
  #+end_src

** Nushell
   This adds support for nushell files

   #+begin_src emacs-lisp :tangle "my-modules/my-nushell-mode.el" :mkdirp yes
     (straight-use-package 'nushell-mode)
     (provide 'my-nushell-mode)
   #+end_src
* Org

  What is org mode? What /isn't/ org mode? Built on top of emacs' outline-mode, org mode
  poorly documented extras, but all baked in and then some) It can make headings, lists,
  emphasize text, store links to other headings in the same or different files and so
  much more.

  In addition to note taking, it handles thinks like task tracking, scheduling, effortless
  ascii table editing, embedded runnable code snippets (think Jupyter notebooks).

  In fact, this emacs configuration is written in org mode, and the embedded emacs lisp
  is extracted and ran to formulate the actual config.

  #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
    (require 'org)
  #+end_src

** modules
   As if org wasn't useful enough as it was, it also ships with a bunch of
   additional modules that add additional features. Check it out by looking
   at the customize-option for [[elisp:(customize-option 'org-modules)][org-modules]]. One useful one added here is
   the ~man~ module, which provides support for linking to man pages (opened
   in emacs' built in man page viewer, obviously)

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (with-eval-after-load 'org
       (require 'ol-man)
       (add-to-list 'org-modules 'ol-man t))
   #+end_src

** Bindings
*** major mode mappings

    These bindings apply to regular commands in org mode. They either add
    or replace base functionality with new features, or ~evil~-ified versions.
    
    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (evil-define-key 'normal org-mode-map
        (kbd "<tab>") 'org-cycle
        (kbd "s-j") 'org-metadown
        (kbd "s-k") 'org-metaup
        (kbd "> >") 'org-shiftmetaright
        (kbd "< <") 'org-shiftmetaleft)
    #+end_src

*** meta mappings

    These are [[*Meta-mode prefix][meta]] leader prefixed keybindings to add additional mode-aware
    contextual functionality.

    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (evil-define-key 'normal org-mode-map
	(kbd "<leader> m a") #'org-archive-subtree
	(kbd "<leader> m e") #'org-export-dispatch
	(kbd "<leader> m p") #'org-publish-project
	(kbd "<leader> m r") #'org-refile
	(kbd "<leader> m l") #'org-insert-link
	(kbd "<leader> m f") #'org-footnote-action
	(kbd "<leader> m i") #'org-toggle-inline-images
        (kbd "<leader> m t") #'org-babel-tangle
	(kbd "<leader> m n") #'org-narrow-to-subtree
	(kbd "<leader> m d") #'org-babel-demarcate-block
	(kbd "<leader> m s s") #'org-schedule
	(kbd "<leader> m s d") #'org-deadline
	(kbd "<leader> m ,") #'org-priority)
    #+end_src

*** Agenda mappings
    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (evil-define-key 'normal org-agenda-mode-map
	(kbd "j") #'org-agenda-next-line
	(kbd "k") #'org-agenda-previous-line
	(kbd "RET") #'org-agenda-switch-to
	(kbd "q") #'org-agenda-quit
	(kbd ".") #'org-agenda-goto-today
	(kbd "l") #'org-agenda-later
	(kbd "h") #'org-agenda-earlier
	(kbd "g w") #'org-agenda-week-view
	(kbd "g d") #'org-agenda-day-view
	(kbd "t") #'org-agenda-todo)
    #+end_src

** Settings

    Org tempo does a lot, I should really look into more of what it has to offer.
    At the very least, I use it for really handy expansion for scr blocks.
    I can type =<s= and hit =TAB= to expand it to =#+begin_src=.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (with-eval-after-load 'org
       (require 'org-tempo))
   #+end_src

   These are a handful of settings that set up default destinations for actions that
   act globally, such as [[*Org capture][org-capture]].

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-directory "~/Dropbox")
     (defvar org-work-dir (concat org-directory "/Work/"))
     (setq org-default-notes-file (concat org-work-dir "index.org"))
   #+end_src

   When inserting images in org files, often they will be way to large to fit into
   the general flow of the document. Through the use of ~#+attr_html: :width NNpx~,
   you cen set how large the image should be displayed as. To enable this, we will
   need to turn off the following setting.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-image-actual-width nil)
   #+end_src

   messing with org src block indentation

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-src-preserve-indentation nil)
   #+end_src

** Org agenda

    Org agenda is cool. It tries to create a day/week/month planner out of any tasks
    or scheduled events it can find in `org-agenda-files'.

    I want it to pull in appointments or reminders from the diary as well since
    those sorts of events don't really make sense to track in org.

    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (setq org-agenda-include-diary t)
      (setq org-agenda-restore-windows-after-quit t)
      (add-to-list 'org-agenda-files org-default-notes-file)
      (add-to-list 'org-agenda-files "~/blog/tech_articles.org")
      (add-to-list 'org-agenda-files "~/Dropbox/notes/")
      (add-to-list 'org-agenda-files "~/Dropbox/notes/journal/")
      (add-to-list 'org-agenda-files "~/schedule.org")
      (add-to-list 'org-agenda-files "~/Dropbox/RBC/Internship/")
    #+end_src

** Org capture

   Org capture aids you in jotting down a quick note when you think of somethimg
   you want to remember but don't want to lose momentum in whatever task you
   were in the middle of.

   Say you were writing a new feature in an application and you realize there's
   a possibility to refactor an adjacent part of the code. Run org capture
   ~M-x org-capture~, and a temporary buffer opens up where you can take your
   note. It will automatically embed any contextual information about where
   you took the note from, such as which file you were editing, the time,
   etc. Once you finish the note, close the buffer with ~C-c C-c~ and the note
   is gone, the window closes and you're back to doing what you were doing
   before.

   Behind the scenes ~org-capture~ stored your note in the file of your choosing
   for you to review on your own time when convenient.

   You can customize what types of notes ~org-capture~ can take, so that you can
   capture any any data you want, place it into any file you want. Just customize
   the variable ~org-capture-templates~.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-capture-templates
	   '(("t" "Todo" entry (file+headline "" "Inbox")
	      "* %?\n %i\n %a")
	     ("r" "Read Article" item (file+headline "" "Reading")
	      "%t %c%?")))
   #+end_src

** Org structures
   Org supports a variety of /structures/. In context, a structure is a block of
   content. Structures can contain source code, comments, quotes, examples, and
   more.

   This can be extended through ~org-structure-template-alist~.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (setq org-structure-template-alist
	   '(("s" . "src")
	     ("e" . "src emacs-lisp")
             ("b" . "src bash")
	     ("t" . "src emacs-lisp :tangle FILENAME :mkdirp yes")))
   #+end_src
** Org publish

   Org allows you to export any org file to a variety of formats:
     - markdown
     - iCalendar (for scheduled/deadline events)
     - ODT (or word if configured) documents
     - plain text (using unicode or ascii elemets)
     - html

   Beyond this however, you can configure org to publish a whole collection
   of org files into a viewable site. It will configure links, css, and more
   for you. You just need to configure the projects variable

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (require 'ox-publish)

     (setq org-publish-use-timestamps-flag nil)

     ;; Don't show validation link
     (setq org-html-validation-link nil)
     ;; Use our own scripts
     (setq org-html-head-include-scripts nil)
     ;; Use our own styles
     (setq org-html-head-include-default-style nil)

     ;; this allows us to get syntax highlighting in source blocks exported to html
     (straight-use-package 'htmlize)

     (setq org-publish-project-alist
	   (list (list "blog"
		       :components (list "blog-org" "blog-static"))
		 (list "blog-org"
		       :base-directory "~/blog/org"
		       :publishing-directory "~/blog/public"
		       :auto-sitemap nil
		       :recursive t
		       :with-broken-links t
                       :with-creator t
		       :section-numbers nil
		       :exclude "README"
		       :export-exclude-tags (list "draft")
		       :with-author "Jon Harder"
		       :with-toc nil
		       :html-htmlize-output-type 'inline-css
		       :html-doctype "html5"
		       :html-html5-fancy t
		       :html-preamble nil
		       :html-postamble nil)
		 (list "blog-static"
		       :base-directory "~/blog/org/"
		       :base-extension "css\\|ico\\|png\\|jpg\\|jpeg\\|gif"
		       :publishing-directory "~/blog/public/"
		       :recursive t
		       :publishing-function #'org-publish-attachment)))
   #+end_src

** Visual enhancements

*** Emphasis markers

    Hide the markers which annotate different emphasis indicators in text.

    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (setq org-hide-emphasis-markers nil)
    #+end_src

*** bullets

    It's nice to have some visual distinction between headers of different levels apart
    from the default increasing number of astericks.

    The org-bullets package replaces the astericks with different bullet glyphs and indents
    them according to level.

    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      (straight-use-package 'org-bullets)
      (add-hook 'org-mode-hook
    	      (lambda ()
    		(org-bullets-mode 1)))
    #+end_src

*** better lists

    It's nice to have unicode bullet glyphs in place of the org `-' and `*'.

    I don't know if I like this...
    #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
      ;; (font-lock-add-keywords 'org-mode
      ;; 			      '(("^ +\\([-*]\\) "
      ;;                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "ยท"))))))
    #+end_src

** Babel

   Org babel is a code embedding feature. It comes included in the default
   install of Org (which itself comes with emacs core).

   Every emacs-lisp block in this file is written in a source block that
   babel will evaluate to form the actual, runnable config.

   This is how [[file:init.el][init.el]] can be just one sexp; telling babel to untangle
   this file in order to extract all the elisp.

   It's far more powerfull than that though, as it allows for [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]]
   in the style of Jupyter notebooks. You can execute a bash script, record the
   results, then feed that data into a python script and export that into an org
   table. This is a huge boon to reproducible research, and documenting processes.

   In order to execute code snippets in an org buffer, that language must be supported
   and enabled. By default, org only authorizes emacs-lisp, but this can be easily
   changed using ~org-bable-do-load-languages~. Your language of choice might not be
   supported out of the box, even if you add it using ~org-babel-do-load-languages~;
   if this is the case, you'll need to load a third-party package to support it.
   These are typically called =ob-$LANG=. For example, to support executing haskell,
   you must install the package =ob-haskell=.

*** Enabling more languages

     #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
       (org-babel-do-load-languages
	'org-babel-load-languages
	'((emacs-lisp . t)
	  (python . t)
	  (calc . t)
	  (shell . t)))
     #+end_src

** toc-org

   Toc org is a package that dynamically generates and maintains a table
   of contents within org documents.

   All you need to do is annotate any heading with ~:TOC:~ and the plugin
   will highjack that heading for use on save.

   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (straight-use-package 'toc-org)
     (add-hook 'org-mode-hook 'toc-org-mode)
#+end_src

** Provide =my-org=
   #+begin_src emacs-lisp :tangle "my-modules/my-org.el" :mkdirp yes
     (provide 'my-org)
   #+end_src

* Search
** Isearch
    There are a variety of entrypoints into emacs' built in searching
    facilities.

    The most basic and straightforward is ~isearch-forward~, bound to
    =C-s= by default.

*** Settings
     #+begin_src emacs-lisp :tangle "my-modules/my-search.el" :mkdirp yes
       (setq isearch-lazy-count t
	     lazy-count-prefix-format "(%s/%s) "
	     lazy-count-suffix-format nil)
     #+end_src
** Occur
   Occur is a handy search functionality which collects all matches of a search
   term found in the current buffer and presents them in a new buffer. From here
   you can quickly see the contents of each matched line, and navigate through
   the source buffer quickly by moving up and down in the occur results buffer.

*** Bindings

   #+begin_src emacs-lisp :tangle "my-modules/my-search.el" :mkdirp yes
     (evil-define-key 'normal occur-mode-map
       (kbd "j") #'next-error-no-select
       (kbd "k") #'previous-error-no-select
       (kbd "RET") #'occur-mode-goto-occurrence
       (kbd "q") #'quit-window)
   #+end_src

** Grep

*** Bindings

   #+begin_src emacs-lisp :tangle "my-modules/my-search.el" :mkdirp yes
     (evil-define-key 'normal grep-mode-map
       (kbd "j") #'next-error-no-select
       (kbd "k") #'previous-error-no-select
       (kbd "q") #'quit-window)
   #+end_src

** Provide =my-search= module
   #+begin_src emacs-lisp :tangle "my-modules/my-search.el" :mkdirp yes
     (provide 'my-search)
   #+end_src

* Shells
** Basic config

   This sets which shell to use when executing commands from dired or compile and friends
   This is different from the shell to use in interactive sessions.

   Because I use [[https://www.nushell.sh][nushell]] for my shell, regular commands like [[man:find][find]] often choke when tools
   like dired assume the posix implementation.

   #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
     (setq explicit-shell-file-name "/opt/homebrew/bin/nu"
           shell-file-name "/bin/zsh")
   #+end_src

** Eshell
*** Environment variables
    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (setenv "GITHUB_KEY" "/Users/jharder/.ssh/docker_github")
    #+end_src
    
*** Settings

    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (straight-use-package 'eshell-syntax-highlighting)
      (eshell-syntax-highlighting-global-mode +1)
      (require 'eshell)
      (require 'em-smart)
      (setq eshell-where-to-jump 'begin)
      (setq eshell-review-quick-commands nil)
      (setq eshell-smart-space-goes-to-end t)
      (setq eshell-visual-commands nil)
    #+end_src

*** Completion

    I want more intelligent completion in eshell.

    This provides smart docker completion, not only for available
    subcommands, but also for realtime completion of available
    images in particular for commands like `run'. 

    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (defconst pcmpl-docker-commands
	'("run" "exec" "ps" "build" "pull" "images" "login" "logout"
	  "search" "version" "info"
	  "compose"))

      (defvar docker-images-command "docker images | tail -n +2 | awk '{ if($1 != \"<none>\") { if($2 == \"<none>\") { print $1 } else { printf(\"%s:%s\\n\", $1, $2) } } }'")

      (defun pcmpl-docker-images ()
	(let ((results (shell-command-to-string docker-images-command)))
	  (string-split results "\n")))

      (defun pcomplete/docker ()
	"Completion for `docker'."
	(pcomplete-here* pcmpl-docker-commands)
	(cond
	 ((pcomplete-match (regexp-opt '("run")) 1)
	  (pcomplete-here* (pcmpl-docker-images)))))

    #+end_src
*** Custom functions
    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
(defun eshell/f (&optional file)
  (interactive)
  (if file
      (find-file file)
    (call-interactively #'find-file)))

(defun eshell/d (&optional dir)
  (interactive)
  (if dir (dired dir) (dired ".")))


(defun eshell/o (file)
  (interactive)
  (find-file-other-window file))
    #+end_src
*** Prompt
    Because eshell is just elisp, the prompt can be set using elisp as well.
    This unlocks the full power of emacs as an environment and can be harnesed
    to make eshell as fancy as you can dream up (and program)

    #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
      (setq eshell-prompt-function
	    (lambda ()
	      (let ((home-path (getenv "HOME")))
		(concat
		 (string-replace home-path "~" (eshell/pwd))
		 " $ "))))

      (setq eshell-prompt-regexp ".*$ ")
    #+end_src
** Eat
  [[https://codeberg.org/akib/emacs-eat][Eat]] is a new kind of shell for emacs, handling fully interactive, fullscreen terminal apps
  cleanly. I think it can replace vterm, and has the benefit of not needing system
  dependencies nor a compilation step.

  #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
    (when nil
      (straight-use-package
       '(eat :type git
	     :host codeberg
	     :repo "akib/emacs-eat"
	     :files ("*.el" ("term" "term/*.el") "*.texi"
		     "*.ti" ("terminfo/e" "terminfo/e/*")
		     ("terminfo/65" "terminfo/65/*")
		     ("integration" "integration/*")
		     (:exclude ".dir-locals.el" "*-tests.el"))))
      (eat-eshell-mode 1))
  #+end_src
** Vterm

   #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
     (straight-use-package 'vterm)
     (straight-use-package 'multi-vterm)
     (setq vterm-shell "/opt/homebrew/bin/nu")
   #+end_src
** Provide =my-shells=
   #+begin_src emacs-lisp :tangle "my-modules/my-shells.el" :mkdirp yes
     (provide 'my-shells)
   #+end_src

   
* Typst
    Typst is great. It's a modern and easy to use reimagining of LaTeX.

** Install package
    #+begin_src emacs-lisp :tangle "my-modules/my-typst.el" :mkdirp yes
      (straight-use-package
       '(typst-ts-mode
	 :type git
	 :host sourcehut
	 :repo "meow_king/typst-ts-mode"
	 :custom
	 (typst-ts-mode-watch-options "--open")))
    #+end_src

** Provide feature =my-typst=
    #+begin_src emacs-lisp :tangle "my-modules/my-typst.el" :mkdirp yes
      (provide 'my-typst)
    #+end_src
 
* Navigation
** Windows

*** ace-window

    Ace window is a handy way to supercharge `other-window' by giving
    each option a lettered target. Simply pressing that letter jumps
    straight to the targeted window, without having to cycle through
    any intermediate windows in the cycle.

    #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
      (straight-use-package 'ace-window)
    #+end_src

*** Window management

    Window management in emacs is very powerful, but oft misunderstood.
    Here are some rules to inform emacs of where I want particular windows
    to go.

    #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
      (setq switch-to-buffer-obey-display-actions t)

      (add-to-list 'display-buffer-alist
		   '("\\*eshell\\*"
		     (display-buffer-at-bottom)
		     (side . bottom)
		     (slot . 0)
		     (window-height . 15)))

      (add-to-list 'display-buffer-alist
		   '("Calendar"
		     (display-buffer-below-selected)
		     (window-height . 15)))
    #+end_src

** Ace jump

  Ace jump is a fantastic package that allows you to jump to any point on the screen with 3
  key presses or less. It's like using your mouse to go wherever you need, but without
  moving your hands off the keyboard.

  #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
    (straight-use-package 'ace-jump-mode)
  #+end_src

** Provide =my-navigation=
  #+begin_src emacs-lisp :tangle "my-modules/my-navigation.el" :mkdirp yes
    (provide 'my-navigation)
  #+end_src

* Email
** Mail server/client setup
  #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
    (setq send-mail-function 'smtpmail-send-it)
    (setq smtpmail-default-smtp-server "smtp.gmail.com"
	  smtpmail-smtp-server "smtp.gmail.com"
	  smtpmail-stream-type 'tls
	  smtpmail-smtp-service 465
	  user-mail-address "jharder@kipsu.com")
  #+end_src

** mbsync setup
  At this point you shouldn't be surprised to find that emacs has decent support for sending
  and receiving emails. It even has a mail retrieval utility built in, rmail.

  This setup requires ~isync~ to be installed on the host machine (a.k.a. the vestigial
  layer that separates emacs from the motherboard).

  *NOTE*: as of [2023-10-16], there is a known issue with mbsync pulling from (at least for gmail)
  remote inboxes. It runs for a time, then errors out with a socket error complaining about
  an unexpected EOF. This has been patched, but is not yet in the homebrew formula, so we install
  from =master=.

  ~brew install --HEAD isync~

  It also requires a mbsync configuration file to work correctly. [[file:~/.mbsyncrc][~/.mbsyncrc]]

** Notmuch
*** Meta: setup
     from there just configure it

     src_sh[]{notmuch setup}

     and let notmuch index your mail

     src_sh[]{notmuch new}
*** Require the project
  #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
    (straight-use-package 'notmuch)
  #+end_src

*** Configuring notmuch
**** Composing emails
    #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
      (defun my-notmuch-message-mode-hook ()
	(auto-fill-mode -1)
	(visual-line-mode 1))

      (add-hook 'notmuch-message-mode-hook #'my-notmuch-message-mode-hook)
    #+end_src

**** Hello sections
    The following configures the "hello" (start) page of notmuch. This page is
    the default view when running the command ~notmuch~.

    This configures the sections on the hello page of notmuch. I don't like the
    header because it doesn't provide any useful information for me.

    I also remove the "recent searches" because these can be easily retrieved
    in buffer history when executing a search with =s=.

    #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
      (setq notmuch-hello-sections
	    '(notmuch-hello-insert-saved-searches
	      notmuch-hello-insert-search
	      notmuch-hello-insert-alltags
	      notmuch-hello-insert-footer))
    #+end_src

**** Saved searches

   #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
     (setq notmuch-saved-searches
	   '((:name "attachments" :query "tag:attachment" :key "a")
	     (:name "inbox" :query "tag:inbox" :key "i")
	     (:name "unread" :query "tag:unread" :key "u")
	     (:name "flagged" :query "tag:flagged" :key "f")
	     (:name "drafts" :query "tag:draft" :key "d")
	     (:name "today's mail" :query "date:today tag:inbox tag:unread" :key ".")
	     (:name "Todo" :query "tag:todo" :key "t")))
   #+end_src

**** Sorting

   #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
     (setq notmuch-search-oldest-first nil)
   #+end_src
*** Bindings
     Evilified bindings to notmuch

**** hello mode
     #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes

       (evil-define-key 'normal notmuch-hello-mode-map
	 (kbd "TAB") #'widget-forward
	 (kbd "RET") #'widget-button-press
	 (kbd "m") #'notmuch-mua-mail
         (kbd "p") #'notmuch-poll-and-refresh-this-buffer
	 (kbd "/") #'notmuch-search
	 (kbd ".") #'notmuch-jump-search
	 (kbd "q") #'notmuch-bury-or-kill-this-buffer)
       #+end_src
       
**** Search mode
       #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
	 (defun notmuch-search-delete-threads (&optional beg end)
	   (interactive (notmuch-interactive-region))
	   (notmuch-search-tag '("+deleted" "-inbox") beg end)
	   (notmuch-search-next-thread))

	 ;; TODO: this function could be made more generic by checking
	 ;; to see which notmuch mode we are in and calling the relevant
	 ;; `notmuch-*-tag' function. e.g. `notmuch-search-tag', `notmuch-show-tag', etc.
	 (defun notmuch-search-add-todo-tag (&optional beg end)
	   (interactive (notmuch-interactive-region))
	   (notmuch-search-tag '("+todo") beg end)
	   (notmuch-search-next-thread))

	 (evil-define-key 'normal notmuch-search-mode-map
	   (kbd "d") #'notmuch-search-delete-threads
	   (kbd "a") #'notmuch-search-archive-thread
	   (kbd "/") #'notmuch-search
	   (kbd "s s") #'notmuch-search-filter
	   (kbd "s j") #'notmuch-jump-search
	   (kbd "s t") #'notmuch-search-filter-by-tag
	   (kbd "j") #'notmuch-search-next-thread
	   (kbd "k") #'notmuch-search-previous-thread
	   (kbd "g r") #'notmuch-refresh-this-buffer
	   (kbd "p") #'notmuch-poll-and-refresh-this-buffer
	   (kbd "q") #'notmuch-bury-or-kill-this-buffer
	   (kbd "t") #'notmuch-search-add-todo-tag
	   (kbd "RET") #'notmuch-search-show-thread
	   (kbd "*") #'notmuch-search-tag-all)

	 (evil-define-key '(visual normal) notmuch-search-mode-map
	   (kbd "-") #'notmuch-search-remove-tag
	   (kbd "+") #'notmuch-search-add-tag
	   (kbd "t") #'notmuch-search-add-todo-tag)
       #+end_src
       
**** Show mode
       #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
	 (defun notmuch-show-delete-thread ()
	   (interactive)
	   (notmuch-show-tag '("+deleted" "-inbox")))

	 (defun notmuch-show-tag-todo ()
	   (interactive)
	   (notmuch-show-tag '("+todo")))

	 (evil-define-key 'normal notmuch-show-mode-map
	   (kbd "a") #'notmuch-show-archive-thread
	   (kbd "d") #'notmuch-show-delete-thread
	   (kbd "t") #'notmuch-add-todo-tag
	   (kbd "r") #'notmuch-show-reply-sender
	   (kbd "q") #'notmuch-bury-or-kill-this-buffer
	   (kbd "g j") #'notmuch-show-next-open-message
	   (kbd "g k") #'notmuch-show-previous-open-message
	   (kbd "TAB") #'notmuch-show-next-button
	   (kbd "RET") #'notmuch-show-toggle-message
	   (kbd "+") #'notmuch-show-add-tag
	   (kbd "-") #'notmuch-show-remove-tag
	   (kbd "t") #'notmuch-show-tag-todo)
       #+end_src


**** Message mode
      This is the mode which handles actually composing messages.

      #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
	(evil-define-key 'normal notmuch-message-mode-map
	  (kbd "<leader> m a") #'mail-add-attachment)
      #+end_src
    
** Provide =my-email=
  #+begin_src emacs-lisp :tangle "my-modules/my-email.el" :mkdirp yes
    (provide 'my-email)
  #+end_src
* Text
** Mixed pitch mode
    Variable pitch (or proportional) fonts are those fonts which have
    different widths on a per-character basis. These are typically
    better for prose.

    Fixed pitch fonts are those which have the same width for each
    character. This means code formatting is preserved relative to
    each line, and does not vary on which letters are typed. This
    tends to be preferred for code.

    Using variable pitch fonts in text-inheriting modes is nice, but
    results in things like org source blocks using the same variable
    pitch as your prose.

    Fortunately, the ~mixed-pitch~ package is aware of the different
    font requirements of such modes and will use both variable and
    fixed pitch fonts in the same buffer according to use.

    #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
      (straight-use-package 'mixed-pitch)
    #+end_src

** Fill column
   Auto-fill mode uses a fixed column number to inform when emacs will
   insert a newline.

   Lets set it to something reasonable.

   #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
     (set-fill-column 80)
   #+end_src
** Text-mode hook
  #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
    (defun my-text-mode-hook ()
      (auto-fill-mode 1)
      (flyspell-mode 1))

    (add-hook 'text-mode-hook #'my-text-mode-hook)
  #+end_src

** Provide =my-text=
  #+begin_src emacs-lisp :tangle "my-modules/my-text.el" :mkdirp yes
    (provide 'my-text)
  #+end_src
* Miscellanious functions
  This is a collection of random functions I've written to help me run one-off tasks.
  
  #+begin_src emacs-lisp :tangle "my-modules/my-util.el" :mkdirp yes
    (defun find-config ()
      "Open the user's config file."
      (interactive)
      (find-file (concat user-emacs-directory "config.org")))

  #+end_src

  This is a small convenience method to load the mastering emacs epub:

  #+begin_src emacs-lisp :tangle "my-modules/my-util.el" :mkdirp yes
    (defun masteringemacs ()
      "Open the masteringemacs epub manual."
      (interactive)
      ;; ensure the nov package is installed
      (require 'nov)
      (find-file "~/Dropbox/Emacs/mastering-emacs-v4.epub"))
  #+end_src

  And provide the module

  
  #+begin_src emacs-lisp :tangle "my-modules/my-util.el" :mkdirp yes
    (provide 'my-util)
  #+end_src

* Magit (git)
  Magit is amazing
  
*** Install the package

  #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
    (straight-use-package 'magit)
    (evil-set-initial-state 'magit-status-mode 'normal)
  #+end_src

*** Set up bindings for the various magit modes
**** Status mode
    Normal mode bindings

    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (evil-define-key '(normal motion) magit-status-mode-map
	(kbd "?") #'magit-dispatch
	(kbd "b") #'magit-branch
	(kbd "q") #'magit-mode-bury-buffer
	(kbd "c") #'magit-commit
	(kbd "e") #'magit-ediff-dwim
	(kbd "j") #'magit-next-line
	(kbd "k") #'magit-previous-line
	(kbd "}") #'magit-section-forward
	(kbd "{") #'magit-section-backward
	(kbd "TAB") #'magit-section-toggle
	(kbd "RET") #'magit-visit-thing
	(kbd "i") #'magit-gitignore
	(kbd "l") #'magit-log
	(kbd "m") #'magit-merge
	(kbd "P") #'magit-push
	(kbd "p") #'magit-pull
	(kbd "M") #'magit-remote
	(kbd "r") #'magit-rebase
        (kbd "t") #'magit-tag
	(kbd "R") #'magit-reset
	(kbd "$") #'magit-process-buffer
	;; delete
	(kbd "d d") 'magit-discard
	(kbd "z") #'magit-stash)
    #+end_src

    Visual mode bindings

    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (evil-define-key '(normal visual) magit-status-mode-map
    	(kbd "s") 'magit-stage
    	(kbd "u") 'magit-unstage)
    #+end_src

**** Log mode
    Normal mode bindings

    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (evil-define-key '(normal motion) magit-log-mode-map
        (kbd "q") 'magit-log-bury-buffer
        (kbd "r") 'magit-rebase
        (kbd "j") 'magit-next-line
        (kbd "k") 'magit-previous-line
        (kbd "}") 'magit-section-forward
        (kbd "{") 'magit-section-backward
        (kbd "RET") 'magit-show-commit
        (kbd "f") #'magit-fetch)
    #+end_src

**** Rebase mode
    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (evil-define-key '(normal) git-rebase-mode-map
	(kbd "p") #'git-rebase-pick
	(kbd "b") #'git-rebase-break
        (kbd "e") #'git-rebase-edit
	(kbd "dd") #'git-rebase-kill-line
	(kbd "s") #'git-rebase-squash
        (kbd "r") #'git-rebase-reword
	(kbd "f") #'git-rebase-fixup
	(kbd "J") #'git-rebase-move-line-down
	(kbd "K") #'git-rebase-move-line-up)
    #+end_src

**** Revision mode
    The revision mode im magit is TODO (what actual part of magit does this even relate to?)
    
    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (evil-define-key '(normal motion) magit-revision-mode-map
	(kbd "j") 'magit-next-line
	(kbd "k") 'magit-previous-line
	(kbd "}") 'magit-section-forward
	(kbd "{") 'magit-section-backward
	(kbd "TAB") 'magit-section-toggle
	(kbd "RET") 'magit-visit-thing
	(kbd "q") 'magit-mode-bury-buffer)
    #+end_src

** Forge
    Forges are a term representing a centralized version control
    location, like github. Magit bundles support for viewing content
    from forges (like pull requests), when required.

    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (straight-use-package 'forge)
    #+end_src
    
** Git gutters
    #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
      (straight-use-package 'git-gutter)
      (global-git-gutter-mode)
    #+end_src
** Provide =my-git=
   #+begin_src emacs-lisp :tangle "my-modules/my-git.el" :mkdirp yes
     (provide 'my-git)
   #+end_src

* Help utilities
  This encompasses man pages, info pages, describe-* windows, etc.
** Helpful package
    #+begin_src emacs-lisp :tangle "my-modules/my-help.el" :mkdirp
      (straight-use-package 'helpful)

      (evil-define-key '(normal motion) helpful-mode-map
	(kbd "q") #'quit-window)

      (evil-define-key '(normal motion) help-mode-map
	(kbd "q") #'quit-window)
    #+end_src
** Info
*** Bindings
    #+begin_src emacs-lisp :tangle "my-modules/my-help.el" :mkdirp yes
      (evil-define-key '(normal motion) Info-mode-map
	(kbd "<tab>") 'Info-next-reference
	(kbd "S-<tab>") 'Info-prev-reference
	(kbd "RET") 'Info-follow-nearest-node
	(kbd "d") 'Info-directory
	(kbd "u") 'Info-up
	(kbd "s") 'Info-search
	(kbd "i") 'Info-index
	(kbd "a") 'info-apropos
	(kbd "q") 'quit-window

        (kbd "y y") 'Info-copy-current-node-name

	[mouse-1] 'Info-mouse-follow-nearest-node
	[follow-link] 'mouse-face
	;; goto
	(kbd "g m") 'Info-menu
	(kbd "g t") 'Info-top-node
	(kbd "g T") 'Info-toc
	(kbd "g j") 'Info-next
	(kbd "g k") 'Info-prev)
    #+end_src
** Man
*** Bindings
     #+begin_src emacs-lisp :tangle "my-modules/my-help.el" :mkdirp yes
       (evil-define-key 'normal Man-mode-map
	 (kbd "q") #'quit-window)
     #+end_src

** Provide =my-help=
   #+begin_src emacs-lisp :tangle "my-modules/my-help.el" :mkdirp yes
     (provide 'my-help)
   #+end_src

* Ibuffer
  Ibuffer is an interactive buffer viewer which allows for searching, filtering
  and acting on all of the open buffers in your session.

** Bindings
  #+begin_src emacs-lisp :tangle "my-modules/my-ibuffer.el" :mkdirp yes
    (evil-define-key '(normal motion) ibuffer-mode-map
      (kbd "<leader> x") 'execute-extended-command
      ;; navigation
      (kbd "{") 'ibuffer-backwards-next-marked
      (kbd "}") 'ibuffer-forward-next-marked
  
      ;; mark commands
      (kbd "J") 'ibuffer-jump-to-buffer
      (kbd "m") 'ibuffer-mark-forward
      (kbd "~") 'ibuffer-toggle-marks
      (kbd "u") 'ibuffer-unmark-forward
      (kbd "DEL") 'ibuffer-unmark-backward
      (kbd "* *") 'ibuffer-mark-special-buffers
      (kbd "U") 'ibuffer-unmark-all-marks
      (kbd "* m") 'ibuffer-mark-by-mode
      (kbd "* M") 'ibuffer-mark-modified-buffers
      (kbd "* r") 'ibuffer-mark-read-only-buffers
      (kbd "* /") 'ibuffer-mark-dired-buffers
      (kbd "* h") 'ibuffer-mark-help-buffers
      (kbd "d") 'ibuffer-mark-for-delete
  
      ;; actions
      (kbd "x") 'ibuffer-do-kill-on-deletion-marks
      (kbd "gr") 'ibuffer-update
  
      ;; immediate actions
      (kbd "A") 'ibuffer-do-view
      (kbd "D") 'ibuffer-do-delete
      (kbd "K") 'ibuffer-do-kill-lines)
  #+end_src

** Provide =my-ibuffer=
  #+begin_src emacs-lisp :tangle "my-modules/my-ibuffer.el" :mkdirp yes
    (provide 'my-ibuffer)
  #+end_src

* Bindings
** Global bindings
   Visual/emacs state commands

   #+begin_src emacs-lisp :tangle "my-modules/my-bindings.el" :mkdirp yes
    (evil-define-key '(insert emacs visual) 'global
      (kbd "s-x") #'execute-extended-command)
   #+end_src

   Normal state commands
   
   #+begin_src emacs-lisp :tangle "my-modules/my-bindings.el" :mkdirp yes
     (evil-define-key 'normal 'global
       (kbd "<leader> ;") #'eval-expression
       (kbd "<leader> q") #'save-buffers-kill-terminal
       (kbd "<leader> x") #'execute-extended-command
       (kbd "g r") #'revert-buffer
       ;; App launcher
       (kbd "<leader> a c") #'calendar
       (kbd "<leader> a a") #'org-agenda
       (kbd "<leader> a n") #'notmuch
       (kbd "<leader> a =") #'calc
       ;;; spotify
       (kbd "<leader> a s") #'smudge-command-map
       ;; buffers
       (kbd "<leader> b b") #'consult-buffer
       (kbd "<leader> b n") #'next-buffer
       (kbd "<leader> b p") #'previous-buffer
       (kbd "<leader> b s") #'save-buffer
       (kbd "<leader> b i") #'ibuffer
       (kbd "<leader> b d") #'evil-delete-buffer
       (kbd "<leader> b k") #'kill-current-buffer
       (kbd "<leader> b r") #'rename-buffer
       ;; config related commands
       (kbd "<leader> c .") #'find-config
       (kbd "<leader> c r") (lambda () (interactive) (load-file user-init-file))
       (kbd "<leader> c t") #'consult-theme
       ;; dired
       (kbd "<leader> d d") #'dired-jump
       (kbd "<leader> d j") #'dired
       ;; evaluation
       (kbd "<leader> e e") #'eval-last-sexp
       (kbd "<leader> e d") #'eval-deful
       ;; files
       (kbd "<leader> f b") #'bookmark-jump
       (kbd "<leader> f i") (lambda () (interactive) (find-file "~/Dropbox/Work/index.org"))
       (kbd "<leader> f B") #'bookmark-set
       (kbd "<leader> f c") #'find-config
       (kbd "<leader> f f") #'find-file
       ;; magit
       (kbd "<leader> g") #'magit
       ;; help(ful) commands
       (kbd "<leader> h i") (lambda (node) (interactive "MNode: ")
			      (info (format "(%s)Top" node)))
       (kbd "<leader> h M") #'info-emacs-manual
       (kbd "<leader> h v") #'helpful-variable
       (kbd "<leader> h f") #'helpful-function
       (kbd "<leader> h k") #'helpful-key
       (kbd "<leader> h m") #'describe-mode
       (kbd "<leader> h r") #'info-display-manual
       ;; imenu
       (kbd "<leader> i") #'consult-imenu
       ;; jumping (ace)
       (kbd "<leader> j") #'ace-jump-word-mode
       ;; org
       (kbd "<leader> o c") #'org-capture
       ;; occur
       (kbd "<leader> o o") #'occur
       ;; project
       (kbd "<leader> p !") #'project-shell-command
       (kbd "<leader> p &") #'project-async-shell-command
       (kbd "<leader> p D") #'project-dired
       (kbd "<leader> p b") #'project-switch-to-buffer
       (kbd "<leader> p d") #'project-find-dir
       (kbd "<leader> p e") #'project-eshell
       (kbd "<leader> p f") #'project-find-file
       (kbd "<leader> p m") #'magit-project-status
       (kbd "<leader> p k") #'project-kill-buffers
       (kbd "<leader> p p") #'project-switch-project
       (kbd "<leader> p /") #'project-find-regexp
       ;; shells
       (kbd "<leader> s e") #'eshell
       ;;; (kbd "<leader> s t") #'eat
       (kbd "<leader> s t") #'multi-vterm
       ;; tab commands
       (kbd "<leader> t t") #'tab-switch
       (kbd "<leader> t n") #'tab-new
       (kbd "<leader> t c") #'tab-close
       (kbd "<leader> t j") #'tab-next
       (kbd "<leader> t k") #'tab-previous
       (kbd "<leader> t f") #'find-file-other-tab
       (kbd "<leader> t b") #'switch-to-buffer-other-tab
       (kbd "<leader> t r") #'tab-rename
       (kbd "<leader> t d") #'dired-other-tab
       ;; windows
       (kbd "<leader> .") #'evil-window-split
       (kbd "<leader> /") #'evil-window-vsplit
       (kbd "<leader> w w") #'ace-window
       (kbd "<leader> w H") #'evil-window-move-far-left
       (kbd "<leader> w L") #'evil-window-move-far-right
       (kbd "<leader> w K") #'evil-window-move-very-top
       (kbd "<leader> w J") #'evil-window-move-very-bottom
       (kbd "<leader> w c") #'evil-window-delete
       (kbd "<leader> w v") #'evil-window-vsplit
       (kbd "<leader> w s") #'evil-window-split
       (kbd "<leader> w o") #'delete-other-windows
       ;; toggles
       (kbd "<leader> T t") #'modus-themes-toggle
       (kbd "<leader> T n") #'display-line-numbers-mode
       (kbd "<leader> T s") #'spacious-padding-mode
       (kbd "<leader> T w") #'whitespace-mode)
   #+end_src

*** S-expression navigation

   #+begin_src emacs-lisp :tangle "my-modules/my-bindings.el" :mkdirp yes
     (evil-define-key 'normal 'global
       "s" nil)
     (evil-define-key 'normal 'global
       ;; (kbd "s l") #'forward-sexp
       (kbd "s h") #'backward-sexp
       (kbd "s j") #'down-list
       (kbd "s k") #'backward-up-list
       (kbd "s d") #'kill-sexp
       (kbd "s $") #'forward-sentence
       (kbd "s 0") #'backward-sentence)
   #+end_src


** Mode specific bindings

   I use ~<leader> m~ as a prefix for any keybindings specific to the active major mode.
   These bindings are found in the mode specific configuration heading.
   These are bound per major mode so that they are context sensitive. This allows me
   to keep the global keybindings relatively uncluttered since I don't need a separate
   prefix for org actions in org buffers, Terraform actions in Terraform buffers, etc.

** Provide =my-bindings=

   #+begin_src emacs-lisp :tangle "my-modules/my-bindings.el" :mkdirp yes
     (provide 'my-bindings)
   #+end_src
   
* Xref
** Bindings
   #+begin_src emacs-lisp :tangle "my-modules/my-xref.el" :mkdirp yes
     (evil-define-key 'normal xref--xref-buffer-mode-map
       (kbd "j") #'xref-next-line
       (kbd "k") #'xref-prev-line
       (kbd "RET") #'xref-goto-xref
       (kbd "q") #'quit-window)
   #+end_src

** Provide =my-xref=
   #+begin_src emacs-lisp :tangle "my-modules/my-xref.el" :mkdirp yes
     (provide 'my-xref)
   #+end_src
